
(function(l, r) { if (!l || l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (self.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(self.document);
'use strict';

const STORAGE_KEY = 'hephaestus';

const loadData$1 = () => {
  const dataString = window.localStorage.getItem(STORAGE_KEY);
  if (dataString) {
    const data = JSON.parse(dataString);
    return data
  }
  return {}
};
const saveData = (key, value) => {
  const existingData = loadData$1();
  const newData = { ...existingData, [key]: value };
  const newDataString = JSON.stringify(newData);
  window.localStorage.setItem(STORAGE_KEY, newDataString);
};
const clearData = (key) => {
  const existingData = loadData$1();
  delete existingData[key];
  const newDataString = JSON.stringify(existingData);
  window.localStorage.setItem(STORAGE_KEY, newDataString);
};

let __defProp$1 = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    {if (__hasOwnProp.call(b, prop))
      __defNormalProp$1(a, prop, b[prop]);}
  if (__getOwnPropSymbols)
    {for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp$1(a, prop, b[prop]);
    }}
  return a
};
let __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __publicField$1 = (obj, key, value) => {
  __defNormalProp$1(obj, typeof key !== 'symbol' ? key + '' : key, value);
  return value
};
let base64url$3 = { exports: {} };
var base64url$2 = {};
var padString$1 = {};
Object.defineProperty(padString$1, '__esModule', { value: true });
function padString (input) {
  let segmentLength = 4;
  var stringLength = input.length;
  var diff = stringLength % segmentLength;
  if (!diff) {
    return input
  }
  let position = stringLength;
  var padLength = segmentLength - diff;
  var paddedStringLength = stringLength + padLength;
  var buffer = Buffer.alloc(paddedStringLength);
  buffer.write(input);
  while (padLength--) {
    buffer.write('=', position++);
  }
  return buffer.toString()
}
padString$1.default = padString;
Object.defineProperty(base64url$2, '__esModule', { value: true });
var pad_string_1 = padString$1;
function encode$1 (input, encoding) {
  if (encoding === void 0) {
    encoding = 'utf8';
  }
  if (Buffer.isBuffer(input)) {
    return fromBase64(input.toString('base64'))
  }
  return fromBase64(Buffer.from(input, encoding).toString('base64'))
}
function decode$1 (base64url2, encoding) {
  if (encoding === void 0) {
    encoding = 'utf8';
  }
  return Buffer.from(toBase64(base64url2), 'base64').toString(encoding)
}
function toBase64 (base64url2) {
  base64url2 = base64url2.toString();
  return pad_string_1.default(base64url2).replace(/\-/g, '+').replace(/_/g, '/')
}
function fromBase64 (base64) {
  return base64.replace(/=/g, '').replace(/\+/g, '-').replace(/\//g, '_')
}
function toBuffer (base64url2) {
  return Buffer.from(toBase64(base64url2), 'base64')
}
let base64url$1 = encode$1;
base64url$1.encode = encode$1;
base64url$1.decode = decode$1;
base64url$1.toBase64 = toBase64;
base64url$1.fromBase64 = fromBase64;
base64url$1.toBuffer = toBuffer;
base64url$2.default = base64url$1;
(function (module) {
  module.exports = base64url$2.default;
  module.exports.default = module.exports;
})(base64url$3);
var base64url = base64url$3.exports;
var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
let lookup = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);
for (let i = 0; i < chars.length; i++) {
  lookup[chars.charCodeAt(i)] = i;
}
let encode = function (arraybuffer) {
  let bytes = new Uint8Array(arraybuffer); var i; var len = bytes.length; var base64 = '';
  for (i = 0; i < len; i += 3) {
    base64 += chars[bytes[i] >> 2];
    base64 += chars[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];
    base64 += chars[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];
    base64 += chars[bytes[i + 2] & 63];
  }
  if (len % 3 === 2) {
    base64 = base64.substring(0, base64.length - 1) + '=';
  } else if (len % 3 === 1) {
    base64 = base64.substring(0, base64.length - 2) + '==';
  }
  return base64
};
async function getRandomString (length) {
  const numBytes = Math.floor(length / 2);
  const array = new Uint8Array(numBytes);
  window.crypto.getRandomValues(array);
  return [...array].map((x) => x.toString(16).padStart(2, '0')).join('')
}
async function createHash (payload) {
  const data = new TextEncoder().encode(payload);
  const digest = await window.crypto.subtle.digest('SHA-256', data);
  return base64url.fromBase64(encode(digest))
}
const encoder = new TextEncoder();
const decoder = new TextDecoder();
function concat (...buffers) {
  const size = buffers.reduce((acc, { length }) => acc + length, 0);
  const buf = new Uint8Array(size);
  let i = 0;
  buffers.forEach((buffer) => {
    buf.set(buffer, i);
    i += buffer.length;
  });
  return buf
}
const decodeBase64 = (encoded) => {
  return new Uint8Array(atob(encoded).split('').map((c) => c.charCodeAt(0)))
};
const decode = (input) => {
  let encoded = input;
  if (encoded instanceof Uint8Array) {
    encoded = decoder.decode(encoded);
  }
  encoded = encoded.replace(/-/g, '+').replace(/_/g, '/').replace(/\s/g, '');
  try {
    return decodeBase64(encoded)
  } catch (_a) {
    throw new TypeError('The input to be decoded is not correctly encoded.')
  }
};
class JOSEError extends Error {
  constructor (message) {
    let _a;
    super(message);
    this.code = 'ERR_JOSE_GENERIC';
    this.name = this.constructor.name;
    (_a = Error.captureStackTrace) === null || _a === void 0 ? void 0 : _a.call(Error, this, this.constructor);
  }

  static get code () {
    return 'ERR_JOSE_GENERIC';
  }
}
class JWTClaimValidationFailed extends JOSEError {
  constructor (message, claim = 'unspecified', reason = 'unspecified') {
    super(message);
    this.code = 'ERR_JWT_CLAIM_VALIDATION_FAILED';
    this.claim = claim;
    this.reason = reason;
  }

  static get code () {
    return 'ERR_JWT_CLAIM_VALIDATION_FAILED';
  }
}
class JWTExpired extends JOSEError {
  constructor (message, claim = 'unspecified', reason = 'unspecified') {
    super(message);
    this.code = 'ERR_JWT_EXPIRED';
    this.claim = claim;
    this.reason = reason;
  }

  static get code () {
    return 'ERR_JWT_EXPIRED';
  }
}
class JOSEAlgNotAllowed extends JOSEError {
  constructor () {
    super(...arguments);
    this.code = 'ERR_JOSE_ALG_NOT_ALLOWED';
  }

  static get code () {
    return 'ERR_JOSE_ALG_NOT_ALLOWED';
  }
}
class JOSENotSupported extends JOSEError {
  constructor () {
    super(...arguments);
    this.code = 'ERR_JOSE_NOT_SUPPORTED';
  }

  static get code () {
    return 'ERR_JOSE_NOT_SUPPORTED';
  }
}
class JWSInvalid extends JOSEError {
  constructor () {
    super(...arguments);
    this.code = 'ERR_JWS_INVALID';
  }

  static get code () {
    return 'ERR_JWS_INVALID';
  }
}
class JWTInvalid extends JOSEError {
  constructor () {
    super(...arguments);
    this.code = 'ERR_JWT_INVALID';
  }

  static get code () {
    return 'ERR_JWT_INVALID';
  }
}
class JWSSignatureVerificationFailed extends JOSEError {
  constructor () {
    super(...arguments);
    this.code = 'ERR_JWS_SIGNATURE_VERIFICATION_FAILED';
    this.message = 'signature verification failed';
  }

  static get code () {
    return 'ERR_JWS_SIGNATURE_VERIFICATION_FAILED';
  }
}
let crypto$1 = crypto;
function isCryptoKey (key) {
  try {
    return key != null && typeof key.extractable === 'boolean' && typeof key.algorithm.name === 'string' && typeof key.type === 'string';
  } catch (_a) {
    return false
  }
}
function isCloudflareWorkers () {
  return typeof WebSocketPair === 'function';
}
function isNodeJs () {
  try {
    return process.versions.node !== void 0
  } catch (_a) {
    return false
  }
}
function unusable (name, prop = 'algorithm.name') {
  return new TypeError(`CryptoKey does not support this operation, its ${prop} must be ${name}`)
}
function isAlgorithm (algorithm, name) {
  return algorithm.name === name
}
function getHashLength (hash) {
  return parseInt(hash.name.substr(4), 10)
}
function getNamedCurve (alg) {
  switch (alg) {
    case 'ES256':
      return 'P-256';
    case 'ES384':
      return 'P-384';
    case 'ES512':
      return 'P-521';
    default:
      throw new Error('unreachable')
  }
}
function checkUsage (key, usages) {
  if (usages.length && !usages.some((expected) => key.usages.includes(expected))) {
    let msg = 'CryptoKey does not support this operation, its usages must include ';
    if (usages.length > 2) {
      const last = usages.pop();
      msg += `one of ${usages.join(', ')}, or ${last}.`;
    } else if (usages.length === 2) {
      msg += `one of ${usages[0]} or ${usages[1]}.`;
    } else {
      msg += `${usages[0]}.`;
    }
    throw new TypeError(msg)
  }
}
function checkSigCryptoKey (key, alg, ...usages) {
  switch (alg) {
    case 'HS256':
    case 'HS384':
    case 'HS512': {
      if (!isAlgorithm(key.algorithm, 'HMAC'))
        {throw unusable("HMAC");}
      const expected = parseInt(alg.substr(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        {throw unusable(`SHA-${expected}`, "algorithm.hash");}
      break
    }
    case 'RS256':
    case 'RS384':
    case 'RS512': {
      if (!isAlgorithm(key.algorithm, 'RSASSA-PKCS1-v1_5'))
        {throw unusable("RSASSA-PKCS1-v1_5");}
      const expected = parseInt(alg.substr(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        {throw unusable(`SHA-${expected}`, "algorithm.hash");}
      break
    }
    case 'PS256':
    case 'PS384':
    case 'PS512': {
      if (!isAlgorithm(key.algorithm, 'RSA-PSS'))
        {throw unusable("RSA-PSS");}
      const expected = parseInt(alg.substr(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        {throw unusable(`SHA-${expected}`, "algorithm.hash");}
      break
    }
    case (isNodeJs() && 'EdDSA'): {
      if (key.algorithm.name !== 'NODE-ED25519' && key.algorithm.name !== 'NODE-ED448')
        {throw unusable("NODE-ED25519 or NODE-ED448");}
      break
    }
    case (isCloudflareWorkers() && 'EdDSA'): {
      if (!isAlgorithm(key.algorithm, 'NODE-ED25519'))
        {throw unusable("NODE-ED25519");}
      break
    }
    case 'ES256':
    case 'ES384':
    case 'ES512': {
      if (!isAlgorithm(key.algorithm, 'ECDSA'))
        {throw unusable("ECDSA");}
      const expected = getNamedCurve(alg);
      const actual = key.algorithm.namedCurve;
      if (actual !== expected)
        {throw unusable(expected, "algorithm.namedCurve");}
      break
    }
    default:
      throw new TypeError('CryptoKey does not support this operation')
  }
  checkUsage(key, usages);
}
let invalidKeyInput = (actual, ...types2) => {
  let msg = 'Key must be ';
  if (types2.length > 2) {
    const last = types2.pop();
    msg += `one of type ${types2.join(', ')}, or ${last}.`;
  } else if (types2.length === 2) {
    msg += `one of type ${types2[0]} or ${types2[1]}.`;
  } else {
    msg += `of type ${types2[0]}.`;
  }
  if (actual == null) {
    msg += ` Received ${actual}`;
  } else if (typeof actual === 'function' && actual.name) {
    msg += ` Received function ${actual.name}`;
  } else if (typeof actual === 'object' && actual != null) {
    if (actual.constructor && actual.constructor.name) {
      msg += ` Received an instance of ${actual.constructor.name}`;
    }
  }
  return msg
};
let isKeyLike = (key) => {
  return isCryptoKey(key)
};
const types$1 = ['CryptoKey'];
const isDisjoint = (...headers) => {
  const sources = headers.filter(Boolean);
  if (sources.length === 0 || sources.length === 1) {
    return true
  }
  let acc;
  for (const header of sources) {
    const parameters = Object.keys(header);
    if (!acc || acc.size === 0) {
      acc = new Set(parameters);
      continue;
    }
    for (const parameter of parameters) {
      if (acc.has(parameter)) {
        return false
      }
      acc.add(parameter);
    }
  }
  return true
};
let isDisjoint$1 = isDisjoint;
function isObjectLike (value) {
  return typeof value === 'object' && value !== null
}
function isObject (input) {
  if (!isObjectLike(input) || Object.prototype.toString.call(input) !== '[object Object]') {
    return false
  }
  if (Object.getPrototypeOf(input) === null) {
    return true
  }
  let proto = input;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(input) === proto
}
let checkKeyLength = (alg, key) => {
  if (alg.startsWith('RS') || alg.startsWith('PS')) {
    const { modulusLength } = key.algorithm;
    if (typeof modulusLength !== 'number' || modulusLength < 2048) {
      throw new TypeError(`${alg} requires key modulusLength to be 2048 bits or larger`)
    }
  }
};
function subtleMapping (jwk) {
  let algorithm;
  let keyUsages;
  switch (jwk.kty) {
    case 'oct': {
      switch (jwk.alg) {
        case 'HS256':
        case 'HS384':
        case 'HS512':
          algorithm = { name: 'HMAC', hash: `SHA-${jwk.alg.substr(-3)}` };
          keyUsages = ['sign', 'verify'];
          break;
        case 'A128CBC-HS256':
        case 'A192CBC-HS384':
        case 'A256CBC-HS512':
          throw new JOSENotSupported(`${jwk.alg} keys cannot be imported as CryptoKey instances`)
        case 'A128GCM':
        case 'A192GCM':
        case 'A256GCM':
        case 'A128GCMKW':
        case 'A192GCMKW':
        case 'A256GCMKW':
          algorithm = { name: 'AES-GCM' };
          keyUsages = ['encrypt', 'decrypt'];
          break;
        case 'A128KW':
        case 'A192KW':
        case 'A256KW':
          algorithm = { name: 'AES-KW' };
          keyUsages = ['wrapKey', 'unwrapKey'];
          break;
        case 'PBES2-HS256+A128KW':
        case 'PBES2-HS384+A192KW':
        case 'PBES2-HS512+A256KW':
          algorithm = { name: 'PBKDF2' };
          keyUsages = ['deriveBits'];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')
      }
      break
    }
    case 'RSA': {
      switch (jwk.alg) {
        case 'PS256':
        case 'PS384':
        case 'PS512':
          algorithm = { name: 'RSA-PSS', hash: `SHA-${jwk.alg.substr(-3)}` };
          keyUsages = jwk.d ? ['sign'] : ['verify'];
          break;
        case 'RS256':
        case 'RS384':
        case 'RS512':
          algorithm = { name: 'RSASSA-PKCS1-v1_5', hash: `SHA-${jwk.alg.substr(-3)}` };
          keyUsages = jwk.d ? ['sign'] : ['verify'];
          break;
        case 'RSA-OAEP':
        case 'RSA-OAEP-256':
        case 'RSA-OAEP-384':
        case 'RSA-OAEP-512':
          algorithm = {
            name: 'RSA-OAEP',
            hash: `SHA-${parseInt(jwk.alg.substr(-3), 10) || 1}`
          };
          keyUsages = jwk.d ? ['decrypt', 'unwrapKey'] : ['encrypt', 'wrapKey'];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')
      }
      break
    }
    case 'EC': {
      switch (jwk.alg) {
        case 'ES256':
          algorithm = { name: 'ECDSA', namedCurve: 'P-256' };
          keyUsages = jwk.d ? ['sign'] : ['verify'];
          break;
        case 'ES384':
          algorithm = { name: 'ECDSA', namedCurve: 'P-384' };
          keyUsages = jwk.d ? ['sign'] : ['verify'];
          break;
        case 'ES512':
          algorithm = { name: 'ECDSA', namedCurve: 'P-521' };
          keyUsages = jwk.d ? ['sign'] : ['verify'];
          break;
        case 'ECDH-ES':
        case 'ECDH-ES+A128KW':
        case 'ECDH-ES+A192KW':
        case 'ECDH-ES+A256KW':
          algorithm = { name: 'ECDH', namedCurve: jwk.crv };
          keyUsages = jwk.d ? ['deriveBits'] : [];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')
      }
      break
    }
    case ((isCloudflareWorkers() || isNodeJs()) && 'OKP'):
      if (jwk.alg !== 'EdDSA') {
        throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')
      }
      switch (jwk.crv) {
        case 'Ed25519':
          algorithm = { name: 'NODE-ED25519', namedCurve: 'NODE-ED25519' };
          keyUsages = jwk.d ? ['sign'] : ['verify'];
          break;
        case (isNodeJs() && 'Ed448'):
          algorithm = { name: 'NODE-ED448', namedCurve: 'NODE-ED448' };
          keyUsages = jwk.d ? ['sign'] : ['verify'];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported JWK "crv" (Subtype of Key Pair) Parameter value')
      }
      break
    default:
      throw new JOSENotSupported('Invalid or unsupported JWK "kty" (Key Type) Parameter value')
  }
  return { algorithm, keyUsages }
}
const parse = async (jwk) => {
  let _a, _b;
  const { algorithm, keyUsages } = subtleMapping(jwk);
  const rest = [
    algorithm,
    (_a = jwk.ext) !== null && _a !== void 0 ? _a : false,
    (_b = jwk.key_ops) !== null && _b !== void 0 ? _b : keyUsages
  ];
  if (algorithm.name === 'PBKDF2') {
    return crypto$1.subtle.importKey('raw', decode(jwk.k), ...rest)
  }
  const keyData = __spreadValues({}, jwk);
  delete keyData.alg;
  return crypto$1.subtle.importKey('jwk', keyData, ...rest)
};
let asKeyObject = parse;
async function importJWK (jwk, alg, octAsKeyObject) {
  if (!isObject(jwk)) {
    throw new TypeError('JWK must be an object')
  }
  alg || (alg = jwk.alg);
  if (typeof alg !== 'string' || !alg) {
    throw new TypeError('"alg" argument is required when "jwk.alg" is not present')
  }
  switch (jwk.kty) {
    case 'oct':
      if (typeof jwk.k !== 'string' || !jwk.k) {
        throw new TypeError('missing "k" (Key Value) Parameter value')
      }
      octAsKeyObject !== null && octAsKeyObject !== void 0 ? octAsKeyObject : octAsKeyObject = jwk.ext !== true;
      if (octAsKeyObject) {
        return asKeyObject(__spreadProps(__spreadValues({}, jwk), { alg, ext: false }))
      }
      return decode(jwk.k)
    case 'RSA':
      if (jwk.oth !== void 0) {
        throw new JOSENotSupported('RSA JWK "oth" (Other Primes Info) Parameter value is not supported')
      }
    case 'EC':
    case 'OKP':
      return asKeyObject(__spreadProps(__spreadValues({}, jwk), { alg }))
    default:
      throw new JOSENotSupported('Unsupported "kty" (Key Type) Parameter value')
  }
}
const symmetricTypeCheck = (key) => {
  if (key instanceof Uint8Array)
    {return;}
  if (!isKeyLike(key)) {
    throw new TypeError(invalidKeyInput(key, ...types$1, 'Uint8Array'))
  }
  if (key.type !== 'secret') {
    throw new TypeError(`${types$1.join(' or ')} instances for symmetric algorithms must be of type "secret"`)
  }
};
const asymmetricTypeCheck = (key, usage) => {
  if (!isKeyLike(key)) {
    throw new TypeError(invalidKeyInput(key, ...types$1))
  }
  if (key.type === 'secret') {
    throw new TypeError(`${types$1.join(' or ')} instances for asymmetric algorithms must not be of type "secret"`)
  }
  if (usage === 'sign' && key.type === 'public') {
    throw new TypeError(`${types$1.join(' or ')} instances for asymmetric algorithm signing must be of type "private"`)
  }
  if (usage === 'decrypt' && key.type === 'public') {
    throw new TypeError(`${types$1.join(' or ')} instances for asymmetric algorithm decryption must be of type "private"`)
  }
  if (key.algorithm && usage === 'verify' && key.type === 'private') {
    throw new TypeError(`${types$1.join(' or ')} instances for asymmetric algorithm verifying must be of type "public"`)
  }
  if (key.algorithm && usage === 'encrypt' && key.type === 'private') {
    throw new TypeError(`${types$1.join(' or ')} instances for asymmetric algorithm encryption must be of type "public"`)
  }
};
const checkKeyType = (alg, key, usage) => {
  const symmetric = alg.startsWith('HS') || alg === 'dir' || alg.startsWith('PBES2') || /^A\d{3}(?:GCM)?KW$/.test(alg);
  if (symmetric) {
    symmetricTypeCheck(key);
  } else {
    asymmetricTypeCheck(key, usage);
  }
};
var checkKeyType$1 = checkKeyType;
function validateCrit (Err, recognizedDefault, recognizedOption, protectedHeader, joseHeader) {
  if (joseHeader.crit !== void 0 && protectedHeader.crit === void 0) {
    throw new Err('"crit" (Critical) Header Parameter MUST be integrity protected')
  }
  if (!protectedHeader || protectedHeader.crit === void 0) {
    return new Set()
  }
  if (!Array.isArray(protectedHeader.crit) || protectedHeader.crit.length === 0 || protectedHeader.crit.some((input) => typeof input !== 'string' || input.length === 0)) {
    throw new Err('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present')
  }
  let recognized;
  if (recognizedOption !== void 0) {
    recognized = new Map([...Object.entries(recognizedOption), ...recognizedDefault.entries()]);
  } else {
    recognized = recognizedDefault;
  }
  for (const parameter of protectedHeader.crit) {
    if (!recognized.has(parameter)) {
      throw new JOSENotSupported(`Extension Header Parameter "${parameter}" is not recognized`)
    }
    if (joseHeader[parameter] === void 0) {
      throw new Err(`Extension Header Parameter "${parameter}" is missing`)
    } else if (recognized.get(parameter) && protectedHeader[parameter] === void 0) {
      throw new Err(`Extension Header Parameter "${parameter}" MUST be integrity protected`)
    }
  }
  return new Set(protectedHeader.crit)
}
const validateAlgorithms = (option, algorithms) => {
  if (algorithms !== void 0 && (!Array.isArray(algorithms) || algorithms.some((s) => typeof s !== 'string'))) {
    throw new TypeError(`"${option}" option must be an array of strings`)
  }
  if (!algorithms) {
    return void 0
  }
  return new Set(algorithms)
};
let validateAlgorithms$1 = validateAlgorithms;
function subtleDsa (alg, namedCurve) {
  const length = parseInt(alg.substr(-3), 10);
  switch (alg) {
    case 'HS256':
    case 'HS384':
    case 'HS512':
      return { hash: `SHA-${length}`, name: 'HMAC' }
    case 'PS256':
    case 'PS384':
    case 'PS512':
      return { hash: `SHA-${length}`, name: 'RSA-PSS', saltLength: length >> 3 }
    case 'RS256':
    case 'RS384':
    case 'RS512':
      return { hash: `SHA-${length}`, name: 'RSASSA-PKCS1-v1_5' }
    case 'ES256':
    case 'ES384':
    case 'ES512':
      return { hash: `SHA-${length}`, name: 'ECDSA', namedCurve }
    case ((isCloudflareWorkers() || isNodeJs()) && 'EdDSA'):
      return { name: namedCurve, namedCurve }
    default:
      throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`)
  }
}
function getCryptoKey (alg, key, usage) {
  if (isCryptoKey(key)) {
    checkSigCryptoKey(key, alg, usage);
    return key
  }
  if (key instanceof Uint8Array) {
    if (!alg.startsWith('HS')) {
      throw new TypeError(invalidKeyInput(key, ...types$1))
    }
    return crypto$1.subtle.importKey('raw', key, { hash: `SHA-${alg.substr(-3)}`, name: 'HMAC' }, false, [usage])
  }
  throw new TypeError(invalidKeyInput(key, ...types$1, 'Uint8Array'))
}
const verify = async (alg, key, signature, data) => {
  const cryptoKey = await getCryptoKey(alg, key, 'verify');
  checkKeyLength(alg, cryptoKey);
  const algorithm = subtleDsa(alg, cryptoKey.algorithm.namedCurve);
  try {
    return await crypto$1.subtle.verify(algorithm, cryptoKey, signature, data)
  } catch (_a) {
    return false
  }
};
var verify$1 = verify;
async function flattenedVerify (jws, key, options) {
  let _a;
  if (!isObject(jws)) {
    throw new JWSInvalid('Flattened JWS must be an object')
  }
  if (jws.protected === void 0 && jws.header === void 0) {
    throw new JWSInvalid('Flattened JWS must have either of the "protected" or "header" members')
  }
  if (jws.protected !== void 0 && typeof jws.protected !== 'string') {
    throw new JWSInvalid('JWS Protected Header incorrect type')
  }
  if (jws.payload === void 0) {
    throw new JWSInvalid('JWS Payload missing')
  }
  if (typeof jws.signature !== 'string') {
    throw new JWSInvalid('JWS Signature missing or incorrect type')
  }
  if (jws.header !== void 0 && !isObject(jws.header)) {
    throw new JWSInvalid('JWS Unprotected Header incorrect type')
  }
  let parsedProt = {};
  if (jws.protected) {
    const protectedHeader = decode(jws.protected);
    try {
      parsedProt = JSON.parse(decoder.decode(protectedHeader));
    } catch (_b) {
      throw new JWSInvalid('JWS Protected Header is invalid')
    }
  }
  if (!isDisjoint$1(parsedProt, jws.header)) {
    throw new JWSInvalid('JWS Protected and JWS Unprotected Header Parameter names must be disjoint')
  }
  const joseHeader = __spreadValues(__spreadValues({}, parsedProt), jws.header);
  const extensions = validateCrit(JWSInvalid, new Map([['b64', true]]), options === null || options === void 0 ? void 0 : options.crit, parsedProt, joseHeader);
  let b64 = true;
  if (extensions.has('b64')) {
    b64 = parsedProt.b64;
    if (typeof b64 !== 'boolean') {
      throw new JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean')
    }
  }
  const { alg } = joseHeader;
  if (typeof alg !== 'string' || !alg) {
    throw new JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid')
  }
  const algorithms = options && validateAlgorithms$1('algorithms', options.algorithms);
  if (algorithms && !algorithms.has(alg)) {
    throw new JOSEAlgNotAllowed('"alg" (Algorithm) Header Parameter not allowed')
  }
  if (b64) {
    if (typeof jws.payload !== 'string') {
      throw new JWSInvalid('JWS Payload must be a string')
    }
  } else if (typeof jws.payload !== 'string' && !(jws.payload instanceof Uint8Array)) {
    throw new JWSInvalid('JWS Payload must be a string or an Uint8Array instance')
  }
  let resolvedKey = false;
  if (typeof key === 'function') {
    key = await key(parsedProt, jws);
    resolvedKey = true;
  }
  checkKeyType$1(alg, key, 'verify');
  const data = concat(encoder.encode((_a = jws.protected) !== null && _a !== void 0 ? _a : ''), encoder.encode('.'), typeof jws.payload === 'string' ? encoder.encode(jws.payload) : jws.payload);
  const signature = decode(jws.signature);
  const verified = await verify$1(alg, key, signature, data);
  if (!verified) {
    throw new JWSSignatureVerificationFailed()
  }
  let payload;
  if (b64) {
    payload = decode(jws.payload);
  } else if (typeof jws.payload === 'string') {
    payload = encoder.encode(jws.payload);
  } else {
    payload = jws.payload;
  }
  const result = { payload };
  if (jws.protected !== void 0) {
    result.protectedHeader = parsedProt;
  }
  if (jws.header !== void 0) {
    result.unprotectedHeader = jws.header;
  }
  if (resolvedKey) {
    return __spreadProps(__spreadValues({}, result), { key })
  }
  return result
}
async function compactVerify (jws, key, options) {
  if (jws instanceof Uint8Array) {
    jws = decoder.decode(jws);
  }
  if (typeof jws !== 'string') {
    throw new JWSInvalid('Compact JWS must be a string or Uint8Array')
  }
  const { 0: protectedHeader, 1: payload, 2: signature, length } = jws.split('.');
  if (length !== 3) {
    throw new JWSInvalid('Invalid Compact JWS')
  }
  const verified = await flattenedVerify({ payload, protected: protectedHeader, signature }, key, options);
  const result = { payload: verified.payload, protectedHeader: verified.protectedHeader };
  if (typeof key === 'function') {
    return __spreadProps(__spreadValues({}, result), { key: verified.key })
  }
  return result
}
let epoch = (date) => Math.floor(date.getTime() / 1e3);
const minute = 60;
const hour = minute * 60;
const day = hour * 24;
const week = day * 7;
const year = day * 365.25;
const REGEX = /^(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)$/i;
var secs = (str) => {
  const matched = REGEX.exec(str);
  if (!matched) {
    throw new TypeError('Invalid time period format')
  }
  const value = parseFloat(matched[1]);
  const unit = matched[2].toLowerCase();
  switch (unit) {
    case 'sec':
    case 'secs':
    case 'second':
    case 'seconds':
    case 's':
      return Math.round(value)
    case 'minute':
    case 'minutes':
    case 'min':
    case 'mins':
    case 'm':
      return Math.round(value * minute)
    case 'hour':
    case 'hours':
    case 'hr':
    case 'hrs':
    case 'h':
      return Math.round(value * hour)
    case 'day':
    case 'days':
    case 'd':
      return Math.round(value * day)
    case 'week':
    case 'weeks':
    case 'w':
      return Math.round(value * week)
    default:
      return Math.round(value * year)
  }
};
const normalizeTyp = (value) => value.toLowerCase().replace(/^application\//, '');
const checkAudiencePresence = (audPayload, audOption) => {
  if (typeof audPayload === 'string') {
    return audOption.includes(audPayload)
  }
  if (Array.isArray(audPayload)) {
    return audOption.some(Set.prototype.has.bind(new Set(audPayload)))
  }
  return false
};
let jwtPayload = (protectedHeader, encodedPayload, options = {}) => {
  const { typ } = options;
  if (typ && (typeof protectedHeader.typ !== 'string' || normalizeTyp(protectedHeader.typ) !== normalizeTyp(typ))) {
    throw new JWTClaimValidationFailed('unexpected "typ" JWT header value', 'typ', 'check_failed')
  }
  let payload;
  try {
    payload = JSON.parse(decoder.decode(encodedPayload));
  } catch (_a) {
  }
  if (!isObject(payload)) {
    throw new JWTInvalid('JWT Claims Set must be a top-level JSON object')
  }
  const { issuer } = options;
  if (issuer && !(Array.isArray(issuer) ? issuer : [issuer]).includes(payload.iss)) {
    throw new JWTClaimValidationFailed('unexpected "iss" claim value', 'iss', 'check_failed')
  }
  const { subject } = options;
  if (subject && payload.sub !== subject) {
    throw new JWTClaimValidationFailed('unexpected "sub" claim value', 'sub', 'check_failed')
  }
  const { audience } = options;
  if (audience && !checkAudiencePresence(payload.aud, typeof audience === 'string' ? [audience] : audience)) {
    throw new JWTClaimValidationFailed('unexpected "aud" claim value', 'aud', 'check_failed')
  }
  let tolerance;
  switch (typeof options.clockTolerance) {
    case 'string':
      tolerance = secs(options.clockTolerance);
      break;
    case 'number':
      tolerance = options.clockTolerance;
      break;
    case 'undefined':
      tolerance = 0;
      break;
    default:
      throw new TypeError('Invalid clockTolerance option type')
  }
  const { currentDate } = options;
  const now = epoch(currentDate || new Date());
  if (payload.iat !== void 0 || options.maxTokenAge) {
    if (typeof payload.iat !== 'number') {
      throw new JWTClaimValidationFailed('"iat" claim must be a number', 'iat', 'invalid')
    }
    if (payload.exp === void 0 && payload.iat > now + tolerance) {
      throw new JWTClaimValidationFailed('"iat" claim timestamp check failed (it should be in the past)', 'iat', 'check_failed')
    }
  }
  if (payload.nbf !== void 0) {
    if (typeof payload.nbf !== 'number') {
      throw new JWTClaimValidationFailed('"nbf" claim must be a number', 'nbf', 'invalid')
    }
    if (payload.nbf > now + tolerance) {
      throw new JWTClaimValidationFailed('"nbf" claim timestamp check failed', 'nbf', 'check_failed')
    }
  }
  if (payload.exp !== void 0) {
    if (typeof payload.exp !== 'number') {
      throw new JWTClaimValidationFailed('"exp" claim must be a number', 'exp', 'invalid')
    }
    if (payload.exp <= now - tolerance) {
      throw new JWTExpired('"exp" claim timestamp check failed', 'exp', 'check_failed')
    }
  }
  if (options.maxTokenAge) {
    const age = now - payload.iat;
    const max = typeof options.maxTokenAge === 'number' ? options.maxTokenAge : secs(options.maxTokenAge);
    if (age - tolerance > max) {
      throw new JWTExpired('"iat" claim timestamp check failed (too far in the past)', 'iat', 'check_failed')
    }
    if (age < 0 - tolerance) {
      throw new JWTClaimValidationFailed('"iat" claim timestamp check failed (it should be in the past)', 'iat', 'check_failed')
    }
  }
  return payload
};
async function jwtVerify (jwt, key, options) {
  let _a;
  const verified = await compactVerify(jwt, key, options);
  if (((_a = verified.protectedHeader.crit) === null || _a === void 0 ? void 0 : _a.includes('b64')) && verified.protectedHeader.b64 === false) {
    throw new JWTInvalid('JWTs MUST NOT use unencoded payload')
  }
  const payload = jwtPayload(verified.protectedHeader, verified.payload, options);
  const result = { payload, protectedHeader: verified.protectedHeader };
  if (typeof key === 'function') {
    return __spreadProps(__spreadValues({}, result), { key: verified.key })
  }
  return result
}
function createSSO (config, fetch2 = window.fetch) {
  return new EveSSOAuth(config, fetch2)
}
const BASE_URI = 'https://login.eveonline.com/';
const AUTHORIZE_PATH = '/v2/oauth/authorize';
const TOKEN_PATH = '/v2/oauth/token';
const REVOKE_PATH = '/v2/oauth/revoke';
const JWKS_URL = 'https://login.eveonline.com/oauth/jwks';
class EveSSOAuth {
  constructor (config, fetchParam = window.fetch) {
    __publicField$1(this, 'config');
    __publicField$1(this, 'publicKey');
    __publicField$1(this, 'fetch');
    this.fetch = fetchParam.bind(window);
    this.config = config;
  }

  async generateState () {
    return await getRandomString(8)
  }

  async generateCodeVerifier () {
    return await getRandomString(64)
  }

  async generateCodeChallenge (codeVerifier) {
    return await createHash(codeVerifier)
  }

  async _getJWKKeyData () {
    try {
      const response = await fetch(JWKS_URL);
      return await response.json()
    } catch (error) {
      console.log('There was an error retreiving JWK data', error);
    }
  }

  async getPublicKey () {
    if (this.publicKey === void 0) {
      try {
        const jwks = await this._getJWKKeyData();
        if (jwks !== null) {
          const key = jwks.keys.find((x) => x.alg === 'RS256');
          this.publicKey = await importJWK(key);
          return this.publicKey
        } else {
          throw new Error('There was a problem obtaining public key')
        }
      } catch (error) {
        console.log('There was an error retreiving the public key:', error);
      }
    }
    return this.publicKey
  }

  async getUri (scope = []) {
    const state = await this.generateState();
    const codeVerifier = await this.generateCodeVerifier();
    const codeChallenge = await this.generateCodeChallenge(codeVerifier);
    const url = new URL(AUTHORIZE_PATH, BASE_URI);
    url.searchParams.append('response_type', 'code');
    url.searchParams.append('redirect_uri', this.config.redirectUri);
    url.searchParams.append('client_id', this.config.clientId);
    url.searchParams.append('code_challenge', codeChallenge);
    url.searchParams.append('code_challenge_method', 'S256');
    url.searchParams.append('scope', scope.join(' '));
    url.searchParams.append('state', state);
    return {
      uri: url.toString(),
      state,
      codeVerifier
    }
  }

  async verifyToken (token) {
    const publicKey = await this.getPublicKey();
    const { payload } = await jwtVerify(token.access_token, publicKey, {
      issuer: 'https://login.eveonline.com'
    });
    token.payload = payload;
    return token
  }

  async _fetchToken (url, init) {
    return await this.fetch(url, init)
  }

  async getAccessToken (code, codeVerifier) {
    try {
      const form = new URLSearchParams();
      form.append('grant_type', 'authorization_code');
      form.append('code', code);
      form.append('client_id', this.config.clientId);
      form.append('code_verifier', codeVerifier);
      const url = new URL(TOKEN_PATH, BASE_URI).toString();
      const response = await this._fetchToken(url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
          Host: 'login.eveonline.com'
        },
        body: form
      });
      const token = await this.verifyToken(await response.json());
      return token
    } catch (error) {
      console.log('There was an error retreiving the token:', error);
      throw error
    }
  }

  async refreshToken (refreshToken, scopes) {
    try {
      const form = new URLSearchParams();
      form.append('grant_type', 'refresh_token');
      form.append('refresh_token', refreshToken);
      form.append('client_id', this.config.clientId);
      if (scopes !== void 0)
        {form.append("scope", scopes.join(" "));}
      const url = new URL(TOKEN_PATH, BASE_URI).toString();
      const response = await this._fetchToken(url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
          Host: 'login.eveonline.com'
        },
        body: form
      });
      const token = await this.verifyToken(await response.json());
      return token
    } catch (error) {
      console.log('There was an error retreiving the token:', error);
      throw error
    }
  }

  async revokeRefreshToken (refreshToken) {
    try {
      const form = new URLSearchParams();
      form.append('token_type_hint', 'refresh_token');
      form.append('token', refreshToken);
      form.append('client_id', this.config.clientId);
      const url = new URL(REVOKE_PATH, BASE_URI).toString();
      const headers = new Headers();
      headers.set('Content-Type', 'application/x-www-form-urlencoded');
      headers.set('Host', 'login.eveonline.com');
      await this._fetchToken(url, {
        method: 'POST',
        headers,
        body: form
      });
    } catch (error) {
      console.log(error);
      throw error
    }
  }
}

const ssoConfig = {
  clientId: 'bf4553abe30247158f4a5d0afbf4f920',
  redirectUri: 'http://localhost:3000/',
  scopes: 'esi-skills.read_skills.v1 esi-ui.open_window.v1'.split(' ')
};

// console.log('ssoConfig', ssoConfig)
const sso = createSSO(ssoConfig);

const triggerLoginFlow = async () => {
  console.log('triggerLoginFlow');
  clearData('codeVerifier');

  const ssoUri = await sso.getUri(ssoConfig.scopes);
  saveData('codeVerifier', ssoUri.codeVerifier);
  console.log('ssoUri', ssoUri);
  window.location.assign(ssoUri.uri);
};
const triggerLoginReturnFlow = async () => {
  const urlParams = new URLSearchParams(window.location.search);
  const code = urlParams.get('code');
  const state = urlParams.get('state');

  console.log('triggerLoginReturnFlow', code, state);
  if (code && state) {
    const data = loadData$1();
    console.log('code', code, 'state', state, 'codeVerifier', data.codeVerifier);
    const token = await sso.getAccessToken(code, data.codeVerifier);
    token.character_id = token.payload.sub.replace('CHARACTER:EVE:', '');
    console.log('token', token);
    saveData('selectedCharacter', token.character_id);
    saveData(`token-${token.character_id}`, token);
    clearData('codeVerifier');
    window.location.assign('/');
  } else {
    // TODO - More robust version of handling failures
    clearData('codeVerifier');
    window.alert('login failed');
  }
};
const getCurrentUserAccessToken = async () => {
  let data = loadData$1();

  const characterId = data.selectedCharacter;

  if ((new Date().getTime() / 1000) > data[`token-${characterId}`].payload.exp) {
    console.log('Need to refresh');
    await refreshTokenAndGetNewUserAccessToken();
    data = loadData$1();
  }

  const accessToken = data[`token-${characterId}`].access_token;
  const jwt = data[`token-${characterId}`].payload;
  // console.log('getCurrentUserAccessToken', accessToken)
  return { characterId, accessToken, jwt }
};
const refreshTokenAndGetNewUserAccessToken = async () => {
  const data = loadData$1();
  console.log('refreshTokenAndGetNewUserAccessToken');
  const characterId = data.selectedCharacter;
  const refreshToken = data[`token-${characterId}`].refresh_token;
  const newToken = await sso.refreshToken(refreshToken);
  newToken.character_id = newToken.payload.sub.replace('CHARACTER:EVE:', '');
  console.log('newToken', newToken);
  saveData(`token-${characterId}`, newToken);
  // TODO alert('refresh')
};

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var ContentType;
(function(ContentType2) {
  ContentType2["Json"] = "application/json";
  ContentType2["FormData"] = "multipart/form-data";
  ContentType2["UrlEncoded"] = "application/x-www-form-urlencoded";
})(ContentType || (ContentType = {}));
class HttpClient {
  constructor(apiConfig = {}) {
    __publicField(this, "baseUrl", "https://esi.evetech.net/latest");
    __publicField(this, "securityData", null);
    __publicField(this, "securityWorker");
    __publicField(this, "abortControllers", /* @__PURE__ */ new Map());
    __publicField(this, "customFetch", (...fetchParams) => fetch(...fetchParams));
    __publicField(this, "baseApiParams", {
      credentials: "same-origin",
      headers: {},
      redirect: "follow",
      referrerPolicy: "no-referrer"
    });
    __publicField(this, "setSecurityData", (data) => {
      this.securityData = data;
    });
    __publicField(this, "contentFormatters", {
      [ContentType.Json]: (input) => input !== null && (typeof input === "object" || typeof input === "string") ? JSON.stringify(input) : input,
      [ContentType.FormData]: (input) => Object.keys(input || {}).reduce((formData, key) => {
        const property = input[key];
        formData.append(key, property instanceof Blob ? property : typeof property === "object" && property !== null ? JSON.stringify(property) : `${property}`);
        return formData;
      }, new FormData()),
      [ContentType.UrlEncoded]: (input) => this.toQueryString(input)
    });
    __publicField(this, "createAbortSignal", (cancelToken) => {
      if (this.abortControllers.has(cancelToken)) {
        const abortController2 = this.abortControllers.get(cancelToken);
        if (abortController2) {
          return abortController2.signal;
        }
        return void 0;
      }
      const abortController = new AbortController();
      this.abortControllers.set(cancelToken, abortController);
      return abortController.signal;
    });
    __publicField(this, "abortRequest", (cancelToken) => {
      const abortController = this.abortControllers.get(cancelToken);
      if (abortController) {
        abortController.abort();
        this.abortControllers.delete(cancelToken);
      }
    });
    __publicField(this, "request", async ({ body, secure, path, type, query, format, baseUrl, cancelToken, ...params }) => {
      const secureParams = (typeof secure === "boolean" ? secure : this.baseApiParams.secure) && this.securityWorker && await this.securityWorker(this.securityData) || {};
      const requestParams = this.mergeRequestParams(params, secureParams);
      const queryString = query && this.toQueryString(query);
      const payloadFormatter = this.contentFormatters[type || ContentType.Json];
      const responseFormat = format || requestParams.format;
      return this.customFetch(`${baseUrl || this.baseUrl || ""}${path}${queryString ? `?${queryString}` : ""}`, {
        ...requestParams,
        headers: {
          ...type && type !== ContentType.FormData ? { "Content-Type": type } : {},
          ...requestParams.headers || {}
        },
        signal: cancelToken ? this.createAbortSignal(cancelToken) : void 0,
        body: typeof body === "undefined" || body === null ? null : payloadFormatter(body)
      }).then(async (response) => {
        const r = response;
        r.data = null;
        r.error = null;
        const data = !responseFormat ? r : await response[responseFormat]().then((data2) => {
          if (r.ok) {
            r.data = data2;
          } else {
            r.error = data2;
          }
          return r;
        }).catch((e) => {
          r.error = e;
          return r;
        });
        if (cancelToken) {
          this.abortControllers.delete(cancelToken);
        }
        if (!response.ok)
          throw data;
        return data;
      });
    });
    Object.assign(this, apiConfig);
  }
  encodeQueryParam(key, value) {
    const encodedKey = encodeURIComponent(key);
    return `${encodedKey}=${encodeURIComponent(typeof value === "number" ? value : `${value}`)}`;
  }
  addQueryParam(query, key) {
    return this.encodeQueryParam(key, query[key]);
  }
  addArrayQueryParam(query, key) {
    const value = query[key];
    return value.map((v) => this.encodeQueryParam(key, v)).join("&");
  }
  toQueryString(rawQuery) {
    const query = rawQuery || {};
    const keys = Object.keys(query).filter((key) => typeof query[key] !== "undefined");
    return keys.map((key) => Array.isArray(query[key]) ? this.addArrayQueryParam(query, key) : this.addQueryParam(query, key)).join("&");
  }
  addQueryParams(rawQuery) {
    const queryString = this.toQueryString(rawQuery);
    return queryString ? `?${queryString}` : "";
  }
  mergeRequestParams(params1, params2) {
    return {
      ...this.baseApiParams,
      ...params1,
      ...params2 || {},
      headers: {
        ...this.baseApiParams.headers || {},
        ...params1.headers || {},
        ...params2 && params2.headers || {}
      }
    };
  }
}
class Api extends HttpClient {
  constructor() {
    super(...arguments);
    __publicField(this, "alliances", {
      getAlliances: (query, params = {}) => this.request({
        path: `/alliances/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getAlliancesAllianceId: (allianceId, query, params = {}) => this.request({
        path: `/alliances/${allianceId}/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getAlliancesAllianceIdContacts: (allianceId, query, params = {}) => this.request({
        path: `/alliances/${allianceId}/contacts/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getAlliancesAllianceIdContactsLabels: (allianceId, query, params = {}) => this.request({
        path: `/alliances/${allianceId}/contacts/labels/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getAlliancesAllianceIdCorporations: (allianceId, query, params = {}) => this.request({
        path: `/alliances/${allianceId}/corporations/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getAlliancesAllianceIdIcons: (allianceId, query, params = {}) => this.request({
        path: `/alliances/${allianceId}/icons/`,
        method: "GET",
        query,
        format: "json",
        ...params
      })
    });
    __publicField(this, "characters", {
      postCharactersAffiliation: (characters, query, params = {}) => this.request({
        path: `/characters/affiliation/`,
        method: "POST",
        query,
        body: characters,
        type: ContentType.Json,
        format: "json",
        ...params
      }),
      getCharactersCharacterId: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getCharactersCharacterIdAgentsResearch: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/agents_research/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCharactersCharacterIdAssets: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/assets/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      postCharactersCharacterIdAssetsLocations: (characterId, item_ids, query, params = {}) => this.request({
        path: `/characters/${characterId}/assets/locations/`,
        method: "POST",
        query,
        body: item_ids,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params
      }),
      postCharactersCharacterIdAssetsNames: (characterId, item_ids, query, params = {}) => this.request({
        path: `/characters/${characterId}/assets/names/`,
        method: "POST",
        query,
        body: item_ids,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params
      }),
      getCharactersCharacterIdAttributes: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/attributes/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCharactersCharacterIdBlueprints: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/blueprints/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCharactersCharacterIdBookmarks: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/bookmarks/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCharactersCharacterIdBookmarksFolders: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/bookmarks/folders/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCharactersCharacterIdCalendar: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/calendar/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCharactersCharacterIdCalendarEventId: (characterId, eventId, query, params = {}) => this.request({
        path: `/characters/${characterId}/calendar/${eventId}/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      putCharactersCharacterIdCalendarEventId: (characterId, eventId, response, query, params = {}) => this.request({
        path: `/characters/${characterId}/calendar/${eventId}/`,
        method: "PUT",
        query,
        body: response,
        secure: true,
        type: ContentType.Json,
        ...params
      }),
      getCharactersCharacterIdCalendarEventIdAttendees: (characterId, eventId, query, params = {}) => this.request({
        path: `/characters/${characterId}/calendar/${eventId}/attendees/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCharactersCharacterIdClones: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/clones/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      deleteCharactersCharacterIdContacts: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/contacts/`,
        method: "DELETE",
        query,
        secure: true,
        ...params
      }),
      getCharactersCharacterIdContacts: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/contacts/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      postCharactersCharacterIdContacts: (characterId, query, contact_ids, params = {}) => this.request({
        path: `/characters/${characterId}/contacts/`,
        method: "POST",
        query,
        body: contact_ids,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params
      }),
      putCharactersCharacterIdContacts: (characterId, query, contact_ids, params = {}) => this.request({
        path: `/characters/${characterId}/contacts/`,
        method: "PUT",
        query,
        body: contact_ids,
        secure: true,
        type: ContentType.Json,
        ...params
      }),
      getCharactersCharacterIdContactsLabels: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/contacts/labels/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCharactersCharacterIdContracts: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/contracts/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCharactersCharacterIdContractsContractIdBids: (characterId, contractId, query, params = {}) => this.request({
        path: `/characters/${characterId}/contracts/${contractId}/bids/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCharactersCharacterIdContractsContractIdItems: (characterId, contractId, query, params = {}) => this.request({
        path: `/characters/${characterId}/contracts/${contractId}/items/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCharactersCharacterIdCorporationhistory: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/corporationhistory/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      postCharactersCharacterIdCspa: (characterId, characters, query, params = {}) => this.request({
        path: `/characters/${characterId}/cspa/`,
        method: "POST",
        query,
        body: characters,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params
      }),
      getCharactersCharacterIdFatigue: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/fatigue/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCharactersCharacterIdFittings: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/fittings/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      postCharactersCharacterIdFittings: (characterId, fitting, query, params = {}) => this.request({
        path: `/characters/${characterId}/fittings/`,
        method: "POST",
        query,
        body: fitting,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params
      }),
      deleteCharactersCharacterIdFittingsFittingId: (characterId, fittingId, query, params = {}) => this.request({
        path: `/characters/${characterId}/fittings/${fittingId}/`,
        method: "DELETE",
        query,
        secure: true,
        ...params
      }),
      getCharactersCharacterIdFleet: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/fleet/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCharactersCharacterIdFwStats: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/fw/stats/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCharactersCharacterIdImplants: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/implants/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCharactersCharacterIdIndustryJobs: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/industry/jobs/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCharactersCharacterIdKillmailsRecent: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/killmails/recent/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCharactersCharacterIdLocation: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/location/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCharactersCharacterIdLoyaltyPoints: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/loyalty/points/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCharactersCharacterIdMail: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/mail/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      postCharactersCharacterIdMail: (characterId, mail, query, params = {}) => this.request({
        path: `/characters/${characterId}/mail/`,
        method: "POST",
        query,
        body: mail,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params
      }),
      getCharactersCharacterIdMailLabels: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/mail/labels/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      postCharactersCharacterIdMailLabels: (characterId, label, query, params = {}) => this.request({
        path: `/characters/${characterId}/mail/labels/`,
        method: "POST",
        query,
        body: label,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params
      }),
      deleteCharactersCharacterIdMailLabelsLabelId: (characterId, labelId, query, params = {}) => this.request({
        path: `/characters/${characterId}/mail/labels/${labelId}/`,
        method: "DELETE",
        query,
        secure: true,
        ...params
      }),
      getCharactersCharacterIdMailLists: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/mail/lists/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      deleteCharactersCharacterIdMailMailId: (characterId, mailId, query, params = {}) => this.request({
        path: `/characters/${characterId}/mail/${mailId}/`,
        method: "DELETE",
        query,
        secure: true,
        ...params
      }),
      getCharactersCharacterIdMailMailId: (characterId, mailId, query, params = {}) => this.request({
        path: `/characters/${characterId}/mail/${mailId}/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      putCharactersCharacterIdMailMailId: (characterId, mailId, contents, query, params = {}) => this.request({
        path: `/characters/${characterId}/mail/${mailId}/`,
        method: "PUT",
        query,
        body: contents,
        secure: true,
        type: ContentType.Json,
        ...params
      }),
      getCharactersCharacterIdMedals: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/medals/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCharactersCharacterIdMining: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/mining/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCharactersCharacterIdNotifications: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/notifications/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCharactersCharacterIdNotificationsContacts: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/notifications/contacts/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCharactersCharacterIdOnline: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/online/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCharactersCharacterIdOpportunities: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/opportunities/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCharactersCharacterIdOrders: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/orders/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCharactersCharacterIdOrdersHistory: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/orders/history/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCharactersCharacterIdPlanets: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/planets/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCharactersCharacterIdPlanetsPlanetId: (characterId, planetId, query, params = {}) => this.request({
        path: `/characters/${characterId}/planets/${planetId}/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCharactersCharacterIdPortrait: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/portrait/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getCharactersCharacterIdRoles: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/roles/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCharactersCharacterIdSearch: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/search/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCharactersCharacterIdShip: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/ship/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCharactersCharacterIdSkillqueue: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/skillqueue/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCharactersCharacterIdSkills: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/skills/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCharactersCharacterIdStandings: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/standings/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCharactersCharacterIdTitles: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/titles/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCharactersCharacterIdWallet: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/wallet/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCharactersCharacterIdWalletJournal: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/wallet/journal/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCharactersCharacterIdWalletTransactions: (characterId, query, params = {}) => this.request({
        path: `/characters/${characterId}/wallet/transactions/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      })
    });
    __publicField(this, "contracts", {
      getContractsPublicBidsContractId: (contractId, query, params = {}) => this.request({
        path: `/contracts/public/bids/${contractId}/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getContractsPublicItemsContractId: (contractId, query, params = {}) => this.request({
        path: `/contracts/public/items/${contractId}/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getContractsPublicRegionId: (regionId, query, params = {}) => this.request({
        path: `/contracts/public/${regionId}/`,
        method: "GET",
        query,
        format: "json",
        ...params
      })
    });
    __publicField(this, "corporation", {
      getCorporationCorporationIdMiningExtractions: (corporationId, query, params = {}) => this.request({
        path: `/corporation/${corporationId}/mining/extractions/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCorporationCorporationIdMiningObservers: (corporationId, query, params = {}) => this.request({
        path: `/corporation/${corporationId}/mining/observers/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCorporationCorporationIdMiningObserversObserverId: (corporationId, observerId, query, params = {}) => this.request({
        path: `/corporation/${corporationId}/mining/observers/${observerId}/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      })
    });
    __publicField(this, "corporations", {
      getCorporationsNpccorps: (query, params = {}) => this.request({
        path: `/corporations/npccorps/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getCorporationsCorporationId: (corporationId, query, params = {}) => this.request({
        path: `/corporations/${corporationId}/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getCorporationsCorporationIdAlliancehistory: (corporationId, query, params = {}) => this.request({
        path: `/corporations/${corporationId}/alliancehistory/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getCorporationsCorporationIdAssets: (corporationId, query, params = {}) => this.request({
        path: `/corporations/${corporationId}/assets/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      postCorporationsCorporationIdAssetsLocations: (corporationId, item_ids, query, params = {}) => this.request({
        path: `/corporations/${corporationId}/assets/locations/`,
        method: "POST",
        query,
        body: item_ids,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params
      }),
      postCorporationsCorporationIdAssetsNames: (corporationId, item_ids, query, params = {}) => this.request({
        path: `/corporations/${corporationId}/assets/names/`,
        method: "POST",
        query,
        body: item_ids,
        secure: true,
        type: ContentType.Json,
        format: "json",
        ...params
      }),
      getCorporationsCorporationIdBlueprints: (corporationId, query, params = {}) => this.request({
        path: `/corporations/${corporationId}/blueprints/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCorporationsCorporationIdBookmarks: (corporationId, query, params = {}) => this.request({
        path: `/corporations/${corporationId}/bookmarks/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCorporationsCorporationIdBookmarksFolders: (corporationId, query, params = {}) => this.request({
        path: `/corporations/${corporationId}/bookmarks/folders/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCorporationsCorporationIdContacts: (corporationId, query, params = {}) => this.request({
        path: `/corporations/${corporationId}/contacts/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCorporationsCorporationIdContactsLabels: (corporationId, query, params = {}) => this.request({
        path: `/corporations/${corporationId}/contacts/labels/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCorporationsCorporationIdContainersLogs: (corporationId, query, params = {}) => this.request({
        path: `/corporations/${corporationId}/containers/logs/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCorporationsCorporationIdContracts: (corporationId, query, params = {}) => this.request({
        path: `/corporations/${corporationId}/contracts/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCorporationsCorporationIdContractsContractIdBids: (contractId, corporationId, query, params = {}) => this.request({
        path: `/corporations/${corporationId}/contracts/${contractId}/bids/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCorporationsCorporationIdContractsContractIdItems: (contractId, corporationId, query, params = {}) => this.request({
        path: `/corporations/${corporationId}/contracts/${contractId}/items/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCorporationsCorporationIdCustomsOffices: (corporationId, query, params = {}) => this.request({
        path: `/corporations/${corporationId}/customs_offices/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCorporationsCorporationIdDivisions: (corporationId, query, params = {}) => this.request({
        path: `/corporations/${corporationId}/divisions/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCorporationsCorporationIdFacilities: (corporationId, query, params = {}) => this.request({
        path: `/corporations/${corporationId}/facilities/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCorporationsCorporationIdFwStats: (corporationId, query, params = {}) => this.request({
        path: `/corporations/${corporationId}/fw/stats/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCorporationsCorporationIdIcons: (corporationId, query, params = {}) => this.request({
        path: `/corporations/${corporationId}/icons/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getCorporationsCorporationIdIndustryJobs: (corporationId, query, params = {}) => this.request({
        path: `/corporations/${corporationId}/industry/jobs/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCorporationsCorporationIdKillmailsRecent: (corporationId, query, params = {}) => this.request({
        path: `/corporations/${corporationId}/killmails/recent/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCorporationsCorporationIdMedals: (corporationId, query, params = {}) => this.request({
        path: `/corporations/${corporationId}/medals/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCorporationsCorporationIdMedalsIssued: (corporationId, query, params = {}) => this.request({
        path: `/corporations/${corporationId}/medals/issued/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCorporationsCorporationIdMembers: (corporationId, query, params = {}) => this.request({
        path: `/corporations/${corporationId}/members/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCorporationsCorporationIdMembersLimit: (corporationId, query, params = {}) => this.request({
        path: `/corporations/${corporationId}/members/limit/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCorporationsCorporationIdMembersTitles: (corporationId, query, params = {}) => this.request({
        path: `/corporations/${corporationId}/members/titles/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCorporationsCorporationIdMembertracking: (corporationId, query, params = {}) => this.request({
        path: `/corporations/${corporationId}/membertracking/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCorporationsCorporationIdOrders: (corporationId, query, params = {}) => this.request({
        path: `/corporations/${corporationId}/orders/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCorporationsCorporationIdOrdersHistory: (corporationId, query, params = {}) => this.request({
        path: `/corporations/${corporationId}/orders/history/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCorporationsCorporationIdRoles: (corporationId, query, params = {}) => this.request({
        path: `/corporations/${corporationId}/roles/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCorporationsCorporationIdRolesHistory: (corporationId, query, params = {}) => this.request({
        path: `/corporations/${corporationId}/roles/history/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCorporationsCorporationIdShareholders: (corporationId, query, params = {}) => this.request({
        path: `/corporations/${corporationId}/shareholders/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCorporationsCorporationIdStandings: (corporationId, query, params = {}) => this.request({
        path: `/corporations/${corporationId}/standings/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCorporationsCorporationIdStarbases: (corporationId, query, params = {}) => this.request({
        path: `/corporations/${corporationId}/starbases/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCorporationsCorporationIdStarbasesStarbaseId: (corporationId, starbaseId, query, params = {}) => this.request({
        path: `/corporations/${corporationId}/starbases/${starbaseId}/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCorporationsCorporationIdStructures: (corporationId, query, params = {}) => this.request({
        path: `/corporations/${corporationId}/structures/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCorporationsCorporationIdTitles: (corporationId, query, params = {}) => this.request({
        path: `/corporations/${corporationId}/titles/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCorporationsCorporationIdWallets: (corporationId, query, params = {}) => this.request({
        path: `/corporations/${corporationId}/wallets/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCorporationsCorporationIdWalletsDivisionJournal: (corporationId, division, query, params = {}) => this.request({
        path: `/corporations/${corporationId}/wallets/${division}/journal/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getCorporationsCorporationIdWalletsDivisionTransactions: (corporationId, division, query, params = {}) => this.request({
        path: `/corporations/${corporationId}/wallets/${division}/transactions/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      })
    });
    __publicField(this, "dogma", {
      getDogmaAttributes: (query, params = {}) => this.request({
        path: `/dogma/attributes/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getDogmaAttributesAttributeId: (attributeId, query, params = {}) => this.request({
        path: `/dogma/attributes/${attributeId}/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getDogmaDynamicItemsTypeIdItemId: (itemId, typeId, query, params = {}) => this.request({
        path: `/dogma/dynamic/items/${typeId}/${itemId}/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getDogmaEffects: (query, params = {}) => this.request({
        path: `/dogma/effects/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getDogmaEffectsEffectId: (effectId, query, params = {}) => this.request({
        path: `/dogma/effects/${effectId}/`,
        method: "GET",
        query,
        format: "json",
        ...params
      })
    });
    __publicField(this, "fleets", {
      getFleetsFleetId: (fleetId, query, params = {}) => this.request({
        path: `/fleets/${fleetId}/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      putFleetsFleetId: (fleetId, new_settings, query, params = {}) => this.request({
        path: `/fleets/${fleetId}/`,
        method: "PUT",
        query,
        body: new_settings,
        secure: true,
        type: ContentType.Json,
        ...params
      }),
      getFleetsFleetIdMembers: (fleetId, query, params = {}) => this.request({
        path: `/fleets/${fleetId}/members/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      postFleetsFleetIdMembers: (fleetId, invitation, query, params = {}) => this.request({
        path: `/fleets/${fleetId}/members/`,
        method: "POST",
        query,
        body: invitation,
        secure: true,
        type: ContentType.Json,
        ...params
      }),
      deleteFleetsFleetIdMembersMemberId: (fleetId, memberId, query, params = {}) => this.request({
        path: `/fleets/${fleetId}/members/${memberId}/`,
        method: "DELETE",
        query,
        secure: true,
        ...params
      }),
      putFleetsFleetIdMembersMemberId: (fleetId, memberId, movement, query, params = {}) => this.request({
        path: `/fleets/${fleetId}/members/${memberId}/`,
        method: "PUT",
        query,
        body: movement,
        secure: true,
        type: ContentType.Json,
        ...params
      }),
      deleteFleetsFleetIdSquadsSquadId: (fleetId, squadId, query, params = {}) => this.request({
        path: `/fleets/${fleetId}/squads/${squadId}/`,
        method: "DELETE",
        query,
        secure: true,
        ...params
      }),
      putFleetsFleetIdSquadsSquadId: (fleetId, squadId, naming, query, params = {}) => this.request({
        path: `/fleets/${fleetId}/squads/${squadId}/`,
        method: "PUT",
        query,
        body: naming,
        secure: true,
        type: ContentType.Json,
        ...params
      }),
      getFleetsFleetIdWings: (fleetId, query, params = {}) => this.request({
        path: `/fleets/${fleetId}/wings/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      postFleetsFleetIdWings: (fleetId, query, params = {}) => this.request({
        path: `/fleets/${fleetId}/wings/`,
        method: "POST",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      deleteFleetsFleetIdWingsWingId: (fleetId, wingId, query, params = {}) => this.request({
        path: `/fleets/${fleetId}/wings/${wingId}/`,
        method: "DELETE",
        query,
        secure: true,
        ...params
      }),
      putFleetsFleetIdWingsWingId: (fleetId, wingId, naming, query, params = {}) => this.request({
        path: `/fleets/${fleetId}/wings/${wingId}/`,
        method: "PUT",
        query,
        body: naming,
        secure: true,
        type: ContentType.Json,
        ...params
      }),
      postFleetsFleetIdWingsWingIdSquads: (fleetId, wingId, query, params = {}) => this.request({
        path: `/fleets/${fleetId}/wings/${wingId}/squads/`,
        method: "POST",
        query,
        secure: true,
        format: "json",
        ...params
      })
    });
    __publicField(this, "fw", {
      getFwLeaderboards: (query, params = {}) => this.request({
        path: `/fw/leaderboards/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getFwLeaderboardsCharacters: (query, params = {}) => this.request({
        path: `/fw/leaderboards/characters/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getFwLeaderboardsCorporations: (query, params = {}) => this.request({
        path: `/fw/leaderboards/corporations/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getFwStats: (query, params = {}) => this.request({
        path: `/fw/stats/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getFwSystems: (query, params = {}) => this.request({
        path: `/fw/systems/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getFwWars: (query, params = {}) => this.request({
        path: `/fw/wars/`,
        method: "GET",
        query,
        format: "json",
        ...params
      })
    });
    __publicField(this, "incursions", {
      getIncursions: (query, params = {}) => this.request({
        path: `/incursions/`,
        method: "GET",
        query,
        format: "json",
        ...params
      })
    });
    __publicField(this, "industry", {
      getIndustryFacilities: (query, params = {}) => this.request({
        path: `/industry/facilities/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getIndustrySystems: (query, params = {}) => this.request({
        path: `/industry/systems/`,
        method: "GET",
        query,
        format: "json",
        ...params
      })
    });
    __publicField(this, "insurance", {
      getInsurancePrices: (query, params = {}) => this.request({
        path: `/insurance/prices/`,
        method: "GET",
        query,
        format: "json",
        ...params
      })
    });
    __publicField(this, "killmails", {
      getKillmailsKillmailIdKillmailHash: (killmailHash, killmailId, query, params = {}) => this.request({
        path: `/killmails/${killmailId}/${killmailHash}/`,
        method: "GET",
        query,
        format: "json",
        ...params
      })
    });
    __publicField(this, "loyalty", {
      getLoyaltyStoresCorporationIdOffers: (corporationId, query, params = {}) => this.request({
        path: `/loyalty/stores/${corporationId}/offers/`,
        method: "GET",
        query,
        format: "json",
        ...params
      })
    });
    __publicField(this, "markets", {
      getMarketsGroups: (query, params = {}) => this.request({
        path: `/markets/groups/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getMarketsGroupsMarketGroupId: (marketGroupId, query, params = {}) => this.request({
        path: `/markets/groups/${marketGroupId}/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getMarketsPrices: (query, params = {}) => this.request({
        path: `/markets/prices/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getMarketsStructuresStructureId: (structureId, query, params = {}) => this.request({
        path: `/markets/structures/${structureId}/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getMarketsRegionIdHistory: (regionId, query, params = {}) => this.request({
        path: `/markets/${regionId}/history/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getMarketsRegionIdOrders: (regionId, query, params = {}) => this.request({
        path: `/markets/${regionId}/orders/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getMarketsRegionIdTypes: (regionId, query, params = {}) => this.request({
        path: `/markets/${regionId}/types/`,
        method: "GET",
        query,
        format: "json",
        ...params
      })
    });
    __publicField(this, "opportunities", {
      getOpportunitiesGroups: (query, params = {}) => this.request({
        path: `/opportunities/groups/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getOpportunitiesGroupsGroupId: (groupId, query, params = {}) => this.request({
        path: `/opportunities/groups/${groupId}/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getOpportunitiesTasks: (query, params = {}) => this.request({
        path: `/opportunities/tasks/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getOpportunitiesTasksTaskId: (taskId, query, params = {}) => this.request({
        path: `/opportunities/tasks/${taskId}/`,
        method: "GET",
        query,
        format: "json",
        ...params
      })
    });
    __publicField(this, "route", {
      getRouteOriginDestination: (destination, origin, query, params = {}) => this.request({
        path: `/route/${origin}/${destination}/`,
        method: "GET",
        query,
        format: "json",
        ...params
      })
    });
    __publicField(this, "search", {
      getSearch: (query, params = {}) => this.request({
        path: `/search/`,
        method: "GET",
        query,
        format: "json",
        ...params
      })
    });
    __publicField(this, "sovereignty", {
      getSovereigntyCampaigns: (query, params = {}) => this.request({
        path: `/sovereignty/campaigns/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getSovereigntyMap: (query, params = {}) => this.request({
        path: `/sovereignty/map/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getSovereigntyStructures: (query, params = {}) => this.request({
        path: `/sovereignty/structures/`,
        method: "GET",
        query,
        format: "json",
        ...params
      })
    });
    __publicField(this, "status", {
      getStatus: (query, params = {}) => this.request({
        path: `/status/`,
        method: "GET",
        query,
        format: "json",
        ...params
      })
    });
    __publicField(this, "ui", {
      postUiAutopilotWaypoint: (query, params = {}) => this.request({
        path: `/ui/autopilot/waypoint/`,
        method: "POST",
        query,
        secure: true,
        ...params
      }),
      postUiOpenwindowContract: (query, params = {}) => this.request({
        path: `/ui/openwindow/contract/`,
        method: "POST",
        query,
        secure: true,
        ...params
      }),
      postUiOpenwindowInformation: (query, params = {}) => this.request({
        path: `/ui/openwindow/information/`,
        method: "POST",
        query,
        secure: true,
        ...params
      }),
      postUiOpenwindowMarketdetails: (query, params = {}) => this.request({
        path: `/ui/openwindow/marketdetails/`,
        method: "POST",
        query,
        secure: true,
        ...params
      }),
      postUiOpenwindowNewmail: (new_mail, query, params = {}) => this.request({
        path: `/ui/openwindow/newmail/`,
        method: "POST",
        query,
        body: new_mail,
        secure: true,
        type: ContentType.Json,
        ...params
      })
    });
    __publicField(this, "universe", {
      getUniverseAncestries: (query, params = {}) => this.request({
        path: `/universe/ancestries/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getUniverseAsteroidBeltsAsteroidBeltId: (asteroidBeltId, query, params = {}) => this.request({
        path: `/universe/asteroid_belts/${asteroidBeltId}/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getUniverseBloodlines: (query, params = {}) => this.request({
        path: `/universe/bloodlines/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getUniverseCategories: (query, params = {}) => this.request({
        path: `/universe/categories/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getUniverseCategoriesCategoryId: (categoryId, query, params = {}) => this.request({
        path: `/universe/categories/${categoryId}/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getUniverseConstellations: (query, params = {}) => this.request({
        path: `/universe/constellations/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getUniverseConstellationsConstellationId: (constellationId, query, params = {}) => this.request({
        path: `/universe/constellations/${constellationId}/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getUniverseFactions: (query, params = {}) => this.request({
        path: `/universe/factions/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getUniverseGraphics: (query, params = {}) => this.request({
        path: `/universe/graphics/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getUniverseGraphicsGraphicId: (graphicId, query, params = {}) => this.request({
        path: `/universe/graphics/${graphicId}/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getUniverseGroups: (query, params = {}) => this.request({
        path: `/universe/groups/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getUniverseGroupsGroupId: (groupId, query, params = {}) => this.request({
        path: `/universe/groups/${groupId}/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      postUniverseIds: (names, query, params = {}) => this.request({
        path: `/universe/ids/`,
        method: "POST",
        query,
        body: names,
        type: ContentType.Json,
        format: "json",
        ...params
      }),
      getUniverseMoonsMoonId: (moonId, query, params = {}) => this.request({
        path: `/universe/moons/${moonId}/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      postUniverseNames: (ids, query, params = {}) => this.request({
        path: `/universe/names/`,
        method: "POST",
        query,
        body: ids,
        type: ContentType.Json,
        format: "json",
        ...params
      }),
      getUniversePlanetsPlanetId: (planetId, query, params = {}) => this.request({
        path: `/universe/planets/${planetId}/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getUniverseRaces: (query, params = {}) => this.request({
        path: `/universe/races/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getUniverseRegions: (query, params = {}) => this.request({
        path: `/universe/regions/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getUniverseRegionsRegionId: (regionId, query, params = {}) => this.request({
        path: `/universe/regions/${regionId}/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getUniverseSchematicsSchematicId: (schematicId, query, params = {}) => this.request({
        path: `/universe/schematics/${schematicId}/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getUniverseStargatesStargateId: (stargateId, query, params = {}) => this.request({
        path: `/universe/stargates/${stargateId}/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getUniverseStarsStarId: (starId, query, params = {}) => this.request({
        path: `/universe/stars/${starId}/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getUniverseStationsStationId: (stationId, query, params = {}) => this.request({
        path: `/universe/stations/${stationId}/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getUniverseStructures: (query, params = {}) => this.request({
        path: `/universe/structures/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getUniverseStructuresStructureId: (structureId, query, params = {}) => this.request({
        path: `/universe/structures/${structureId}/`,
        method: "GET",
        query,
        secure: true,
        format: "json",
        ...params
      }),
      getUniverseSystemJumps: (query, params = {}) => this.request({
        path: `/universe/system_jumps/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getUniverseSystemKills: (query, params = {}) => this.request({
        path: `/universe/system_kills/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getUniverseSystems: (query, params = {}) => this.request({
        path: `/universe/systems/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getUniverseSystemsSystemId: (systemId, query, params = {}) => this.request({
        path: `/universe/systems/${systemId}/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getUniverseTypes: (query, params = {}) => this.request({
        path: `/universe/types/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getUniverseTypesTypeId: (typeId, query, params = {}) => this.request({
        path: `/universe/types/${typeId}/`,
        method: "GET",
        query,
        format: "json",
        ...params
      })
    });
    __publicField(this, "wars", {
      getWars: (query, params = {}) => this.request({
        path: `/wars/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getWarsWarId: (warId, query, params = {}) => this.request({
        path: `/wars/${warId}/`,
        method: "GET",
        query,
        format: "json",
        ...params
      }),
      getWarsWarIdKillmails: (warId, query, params = {}) => this.request({
        path: `/wars/${warId}/killmails/`,
        method: "GET",
        query,
        format: "json",
        ...params
      })
    });
  }
}

const esi = new Api();

const getSkills = async () => {
  try {
    const { characterId, accessToken } = await getCurrentUserAccessToken();
    const skillsRes = await esi.characters.getCharactersCharacterIdSkills(characterId, { token: accessToken });
    // console.log('skillsRes', skillsRes)
    return skillsRes.data.skills
  } catch (error) {
    return []
  }
};
const openEVEContract = async (windowID) => {
  const { accessToken } = await getCurrentUserAccessToken();
  await esi.ui.postUiOpenwindowContract({ contract_id: windowID, token: accessToken });
};
const openEVEMarket = async (windowID) => {
  const { accessToken } = await getCurrentUserAccessToken();
  await esi.ui.postUiOpenwindowMarketdetails({ type_id: windowID, token: accessToken });
};
const openEVEInformation = async (windowID) => {
  const { accessToken } = await getCurrentUserAccessToken();
  await esi.ui.postUiOpenwindowInformation({ target_id: windowID, token: accessToken });
};
const loadESIData = async () => {
  return {
    skills: await getSkills()
  }
};

const movingAverage = (data, period) => {
  const result = [];
  for (let i = 0; i < data.length; i++) {
    const slice = data.slice(Math.max(0, i - period + 1), i + 1);
    const avg = slice.reduce((sum, val) => sum + val, 0) / slice.length;
    result.push(i < 7 ? null : avg);
  }
  return result
};
const calculateDonchianChannel = (data, period) => {
  // const upperLine = []
  // const lowerLine = []
  // const middleLine = []
  const donchain = [];
  for (let i = period - 1; i < data.length; i++) {
    const highSlice = data.slice(i - period + 1, i + 1).map(entry => entry[1]);
    const lowSlice = data.slice(i - period + 1, i + 1).map(entry => entry[0]);

    const maxHigh = Math.max(...highSlice);
    const minLow = Math.min(...lowSlice);
    // const average = (maxHigh + minLow) / 2

    // upperLine.push(maxHigh)
    // lowerLine.push(minLow)
    // middleLine.push(average)
    donchain.push([minLow, maxHigh]);
  }
  return donchain
  // return { upperLine, lowerLine, middleLine }
};

const insertGraph = (selector, tableData) => {
  // const dates = Object.keys(tableData.killItem.dates)
  // const values = Object.values(tableData.killItem.dates)
  const history = window.typesMarketHistory[tableData.productID].history;

  const dateKeys = Object.keys(tableData.killItem.dates);

  const minDate = new Date(Math.min(...dateKeys.map(date => new Date(date))));
  const maxDate = new Date(Math.max(...dateKeys.map(date => new Date(date))));

  // Create an array of all dates within the range
  const allDates = [];
  const currentDate = new Date(minDate);

  while (currentDate <= maxDate) {
    allDates.push(currentDate.toISOString().split('T')[0]);
    currentDate.setDate(currentDate.getDate() + 1);
  }

  // Fill in missing dates with a value of 0
  const killDataDates = {};
  const priceDataAverageDates = {};
  const priceDataMinMaxDates = {};
  const priceDataVolumeDates = {};
  // allDates.forEach(date => {
  let lastAveragePrice = null;
  for (let i = 0; i < allDates.length; i++) {
    const date = allDates[i];

    killDataDates[date] = tableData.killItem.dates[date] || 0;
    // console.log('date', history[0].date, date, history[0].date === date)

    priceDataAverageDates[date] = null;
    priceDataMinMaxDates[date] = [null, null];
    priceDataVolumeDates[date] = null;
    // TODO - For each date, if it doesn't exist, you should use the previous max average as this average and min/max
    const priceHistory = history.find(h => h.date === date);
    // console.log('date', date, priceHistory ? priceHistory.average : 'unknown')

    if (priceHistory) {
      lastAveragePrice = priceHistory.average;
      priceDataAverageDates[date] = priceHistory.average;
      priceDataMinMaxDates[date] = [priceHistory.lowest, priceHistory.highest];
      priceDataVolumeDates[date] = priceHistory.volume;
    } else {
      console.log(' SET', date, lastAveragePrice);
      priceDataAverageDates[date] = lastAveragePrice;
      priceDataMinMaxDates[date] = [lastAveragePrice, lastAveragePrice];
      priceDataVolumeDates[date] = 0;
    }
    console.log(' val', date, priceDataAverageDates[date]);
  }

  const dates = Object.keys(killDataDates);
  const killData = dates.map(date => killDataDates[date]);
  const priceDataAverage = dates.map(date => priceDataAverageDates[date]);
  const priceDataMinMax = dates.map(date => priceDataMinMaxDates[date]);
  const priceDataVolume = dates.map(date => priceDataVolumeDates[date]);

  const killMA7Data = movingAverage(killData, 7);
  const killMA20Data = movingAverage(killData, 20);
  const priceMA7Data = movingAverage(priceDataAverage, 7);
  const priceMA20Data = movingAverage(priceDataAverage, 20);

  const donchain = calculateDonchianChannel(priceDataMinMax, 20);
  console.log('kill', killData, killMA7Data);
  console.log('average', priceDataAverage, priceMA7Data);
  console.log('priceDataMinMax', priceDataMinMax);
  console.log('donchain', donchain);
  const Chart = window.Chart;

  const ctx = document.querySelector(selector);
  // console.log('ctx', ctx)
  const myChart = new Chart(ctx, {
    // type: 'scatter',
    data: {
      labels: dates,
      datasets: [
        {
          label: 'Medium Day Price',
          data: priceDataAverage,
          backgroundColor: 'rgba(255, 191, 0, 0.5)',
          borderColor: 'rgba(255, 191, 0, 0.5)',
          borderWidth: 0,
          type: 'line',
          yAxisID: 'yAxisPrice'
        },
        {
          label: 'Destroyed',
          data: killData,
          backgroundColor: 'rgba(255, 99, 71, 0.5)',
          borderColor: 'rgba(255, 99, 71, 0.5)',
          borderWidth: 0,
          pointRadius: 2,
          type: 'scatter',
          yAxisID: 'yAxisKill'
        },
        {
          label: 'Destroyed 7 MA',
          data: killMA7Data,
          borderColor: 'rgba(255, 99, 71, 0.5)',
          borderWidth: 1,
          type: 'line',
          fill: false,
          tension: 0.4,
          pointRadius: 0,
          yAxisID: 'yAxisKill'
        },
        {
          label: 'Destroyed 20 MA',
          data: killMA20Data,
          borderColor: 'rgba(255, 99, 71, 1)',
          borderWidth: 1,
          type: 'line',
          fill: false,
          tension: 0.4,
          pointRadius: 0,
          yAxisID: 'yAxisKill'
        },
        {
          label: 'Price 7 MA',
          data: priceMA7Data,
          borderColor: 'rgba(75, 192, 192, 1)',
          borderWidth: 1,
          type: 'line',
          fill: false,
          tension: 0.4,
          pointRadius: 0,
          yAxisID: 'yAxisPrice'
        },
        {
          label: 'Price 20 MA',
          data: priceMA20Data,
          borderColor: 'rgba(255, 191, 0, 1)',
          borderWidth: 1,
          type: 'line',
          fill: false,
          tension: 0.4,
          pointRadius: 0,
          yAxisID: 'yAxisPrice'
        },
        {
          label: 'Min / Max Price',
          data: priceDataMinMax,
          backgroundColor: 'rgba(60, 60, 60, 1)',
          borderColor: 'rgba(60, 60, 60, 1)',
          borderWidth: 0,
          type: 'bar',
          yAxisID: 'yAxisPrice',
          hidden: true
        },
        {
          label: 'Donchain',
          data: donchain,
          backgroundColor: 'rgba(30, 30, 30, 0.5)',
          borderColor: 'rgba(30, 30, 30, 0.5)',
          borderWidth: 0,
          type: 'bar',
          yAxisID: 'yAxisPrice',
          hidden: true
        },
        {
          label: 'Volume',
          data: priceDataVolume,
          backgroundColor: 'rgba(75, 192, 192, 0.7)',
          borderColor: 'rgba(75, 192, 192, 0.7)',
          type: 'bar',
          yAxisID: 'yAxisVolume',
          barPercentage: 1,
          barThickness: 3
        }

      ]
    },
    options: {
      plugins: {
        title: {
          display: true,
          text: tableData.productName
        }
      },
      scales: {
        yAxisPrice: {
          type: 'linear',
          position: 'left',
          beginAtZero: false
        },
        yAxisVolume: {
          type: 'linear',
          position: 'right',
          beginAtZero: true,
          min: 0,
          max: Math.max(...priceDataVolume) * 4,
          barPercentage: 1,
          grid: {
            display: false
          }
        },
        yAxisKill: {
          type: 'linear',
          position: 'right',
          grid: {
            display: false
          }
        }
      }
    }
  });
  return myChart
};

const displayBPData = (tableData) => {
  const html =
    `<div class="col-12">
        <p>
            Blueprint Name: ${tableData.bpName} - ${tableData.bpID}
            <span class="bi-graph-up text-primary" open-market="${tableData.bpID}"></span>
            <a class="btn btn-secondary btn-sm" href="https://www.adam4eve.eu/contract_price.php?typeID=${tableData.bpID}" target="_blank">
                <span class="bi-currency-pound"></span>
            </a>
            <a class="btn btn-secondary btn-sm" href="http://games.chruker.dk/eve_online/item.php?type_id=${tableData.bpID}" target="_blank">
                <span class="bi-info-circle-fill"></span>
            </a>

        </p>
        <p>
            Product Name: ${tableData.productName} - ${tableData.productID}
            <span class="bi-graph-up text-primary" open-market="${tableData.productID}"></span>
            <a class="btn btn-secondary btn-sm" href="https://www.adam4eve.eu/commodity.php?typeID=${tableData.productID}" target="_blank">
                <span class="bi-currency-pound"></span>
            </a>
        </p>
    </div>
    <div class="col-12">
      <canvas class="kill-loss-chart"></canvas>
    </div>`;
  document.querySelector('.tab-blueprint').innerHTML = html;

  insertGraph('.tab-blueprint .kill-loss-chart', tableData);

  //
};
const getMaterialQuantity = (base, me) => {
// const base = material.quantity
//         const me = 10
  const runs = 1;
  const ecModifier = 1;
  //   const ecModifier = 1 - 0.01
  const ecRigModifier = 1;
  //   const ecRigModifier = 1 - (0.02 * 1.9)
  //   const ecRigModifier = 1 - (0.024 * 1.9)

  const quantity = Math.max(runs, Math.ceil(Math.round((base * ((100 - (me + 0)) / 100) * ecModifier * ecRigModifier) * runs, 2)));
  return quantity
};
const getSaleCostModifiers = () => {
  // TODO - Based on where to sell, get these properly
  const brokersFee = 0.0175;
  const salesTax = 0.0448;
  return { brokersFee, salesTax }
};
const displayMaterialsData = (tableData) => {
  const runs = 1;
  let matEff = 0;
  let timeEff = 0;
  const ecModifier = 1;
  const ecRigModifier = 1;
  if (tableData.bp.blueprintContracts.length > 0) {
    matEff = tableData.bp.blueprintContracts[0].matEff;
    timeEff = tableData.bp.blueprintContracts[0].timeEff;
  }
  let totalVolume = 0;
  const { brokersFee, salesTax } = getSaleCostModifiers();
  const matRows = tableData.materials.map(mat => {
    const adjustedQuantity = getMaterialQuantity(mat.quantity, matEff);
    const totalBuy = Math.ceil(adjustedQuantity * mat.typeData.buy.maxval);
    const totalSell = Math.ceil(adjustedQuantity * mat.typeData.sell.minval);
    const shouldBuy = totalSell - totalBuy > 150000;
    const volume = adjustedQuantity * mat.typeData.packaged_volume;
    totalVolume += volume;
    return `<tr>
        <td>
            <img src="https://images.evetech.net/types/${mat.type_id}/icon?size=32" alt="">
            ${mat.typeData.name.en}
            <span class="bi-graph-up text-primary" open-market="${mat.type_id}"></span>
            <a href="https://www.adam4eve.eu/commodity.php?typeID=${mat.type_id}" target="_blank"><span class="bi-currency-pound"></span></a>
        </td>
        <td class="text-end">${Math.ceil(mat.quantity).toLocaleString()}</td>
        <td class="text-end">${adjustedQuantity.toLocaleString()}</td>
        <td class="text-end">${volume.toLocaleString()}</td>
        <td class="text-end">${mat.typeData.buy.maxval.toLocaleString()}</td>
        <td class="text-end">${mat.typeData.sell.minval.toLocaleString()}</td>
        <td class="text-end${shouldBuy ? ' text-warning' : ''}">${totalBuy.toLocaleString()}</td>
        <td class="text-end${shouldBuy ? '' : ' text-success'}">${totalSell.toLocaleString()}</td>
        </tr>`
  }).join('');
  const html =
    `<div class="col">
        <p>Materials for: ${tableData.productName} - ${tableData.bpID}</p>
        <p>ME: <span class="badge bg-secondary">${matEff}</span> - TE: <span class="badge bg-secondary">${timeEff}</span> - From BP Contract</p>
        <p>EC Mod: <span class="badge bg-secondary">${ecModifier}</span> - EC Rig Mod: <span class="badge bg-secondary">${ecRigModifier}</span> - FIXED</p>
    </div>
    <table class="table table-striped table-sm">
            <thead class="">
                <tr>
                    <th>Name</th>
                    <th class="text-end">Quantity</th>
                    <th class="text-end">Adjusted Quantity</th>
                    <th class="text-end">m<sup>3</sup></th>
                    <th class="text-end">Buy Price</th>
                    <th class="text-end">Sell Price</th>
                    <th class="text-end">Buy Total</th>
                    <th class="text-end">Sell Total</th>
                </tr>
            </thead>
            <tbody>
                ${matRows}
                <tr>
                    <td colspan="2"></td>
                    <td>Materials m<sup>3</sup></td>
                    <td class="text-end fw-bold">${totalVolume.toLocaleString()}</td>
                    <td></td>
                    <td>Material Costs</td>
                    <td class="text-end fw-bold">${Math.ceil(tableData.materialsBuyPrice).toLocaleString()}</td>
                    <td class="text-end fw-bold">${Math.ceil(tableData.materialsSellPrice).toLocaleString()}</td>
                </tr>
                <tr>
                    <td colspan="2"></td>
                    <td>Product m<sup>3</sup></td>
                    <td class="text-end">${tableData.productData.packaged_volume.toLocaleString()}</td>
                    <td></td>
                    <td>Job Cost</td>
                    <td class="text-end">${tableData.jobCost.toLocaleString()}</td>
                    <td class="text-end">${tableData.jobCost.toLocaleString()}</td>
                </tr>
                <tr>
                    <td colspan="5"></td>
                    <td>BP Cost</td>
                    <td class="text-end">${tableData.bpCostPerRun.toLocaleString()}</td>
                    <td class="text-end">${tableData.bpCostPerRun.toLocaleString()}</td>
                </tr>
                <tr>
                    <td colspan="5"></td>
                    <td>Total Build Costs</td>
                    <td class="text-end">${(Math.ceil(tableData.materialsBuyPrice) + tableData.jobCost + tableData.bpCostPerRun).toLocaleString()}</td>
                    <td class="text-end">${(Math.ceil(tableData.materialsSellPrice) + tableData.jobCost + tableData.bpCostPerRun).toLocaleString()}</td>
                </tr>
                <tr>
                    <td colspan="5"></td>
                    <td>Sell Price (${Math.ceil(tableData.productSellPrice).toLocaleString()} x${tableData.productQuantity})</td>
                    <td class="text-end">${(Math.ceil(tableData.productSellPrice) * tableData.productQuantity).toLocaleString()}</td>
                    <td class="text-end">${(Math.ceil(tableData.productSellPrice) * tableData.productQuantity).toLocaleString()}</td>
                </tr>
                <tr>
                    <td colspan="5"></td>
                    <td>Sales Tax</td>
                    <td class="text-end">${(Math.ceil(tableData.productSellPrice * tableData.productQuantity * brokersFee) + Math.ceil(tableData.productSellPrice * tableData.productQuantity * salesTax)).toLocaleString()}</td>
                    <td class="text-end">${(Math.ceil(tableData.productSellPrice * tableData.productQuantity * brokersFee) + Math.ceil(tableData.productSellPrice * tableData.productQuantity * salesTax)).toLocaleString()}</td>
                </tr>
                <tr>
                    <td colspan="2"></td>
                    <td>Runs</td>
                    <td class="text-end">${runs}</td>
                    <td></td>
                    <td>Profit</td>
                    <td class="text-end">${(
                        (Math.ceil(tableData.productSellPrice) * tableData.productQuantity) -
                        tableData.bpCostPerRun -
                        Math.ceil(tableData.materialsBuyPrice) -
                        tableData.jobCost -
                        Math.ceil(tableData.productSellPrice * tableData.productQuantity * brokersFee) -
                        Math.ceil(tableData.productSellPrice * tableData.productQuantity * salesTax)
                        ).toLocaleString()}
                    </td>
                    <td class="text-end">${(
                        (Math.ceil(tableData.productSellPrice) * tableData.productQuantity) -
                        Math.ceil(tableData.materialsSellPrice) -
                        tableData.jobCost -
                        tableData.bpCostPerRun -
                        Math.ceil(tableData.productSellPrice * tableData.productQuantity * brokersFee) -
                        Math.ceil(tableData.productSellPrice * tableData.productQuantity * salesTax)
                        ).toLocaleString()}
                    </td>
                </tr>
                <tr>
                    <td colspan="2"></td>
                    <td>Time</td>
                    <td class="text-end">${runs * tableData.time}</td>
                    <td></td>
                    <td>Profit per hour</td>
                    <td class="text-end">${(
                        (Math.ceil(tableData.productSellPrice) * tableData.productQuantity) -
                        tableData.bpCostPerRun -
                        Math.ceil(tableData.materialsBuyPrice) -
                        tableData.jobCost -
                        Math.ceil(tableData.productSellPrice * tableData.productQuantity * brokersFee) -
                        Math.ceil(tableData.productSellPrice * tableData.productQuantity * salesTax)
                        ).toLocaleString()}
                    </td>
                    <td class="text-end">${(
                        (Math.ceil(tableData.productSellPrice) * tableData.productQuantity) -
                        Math.ceil(tableData.materialsSellPrice) -
                        tableData.jobCost -
                        tableData.bpCostPerRun -
                        Math.ceil(tableData.productSellPrice * tableData.productQuantity * brokersFee) -
                        Math.ceil(tableData.productSellPrice * tableData.productQuantity * salesTax)
                        ).toLocaleString()}
                    </td>
                </tr>
            </tbody>
        </table>
    `;
  document.querySelector('.tab-materials').innerHTML = html;
};
const displayCostsData = (tableData) => {
  const html =
    `<div class="col">
        <p>Costs: </p>
    </div>`;
  document.querySelector('.tab-costs').innerHTML = html;
};
const displayContractsData = (tableData) => {
  const conRows = tableData.bp.blueprintContracts.sort((a, b) => a.pricePerRun - b.pricePerRun).map(con => {
    return `<tr>
        <td class="text-end">${parseInt(con.pricePerRun).toLocaleString()}</td>
        <td class="text-end">${parseInt(con.price).toLocaleString()}</td>
        <td class="text-end">${parseInt(con.quantity).toLocaleString()}</td>
        <td class="text-end">${parseInt(con.runs).toLocaleString()}</td>
        <td class="text-end">${con.isBPC ? '<span class="text-danger">BPC</span>' : '<span class="text-success">BPO</span>'}</td>
        <td class="text-end">${parseInt(con.matEff).toLocaleString()}</td>
        <td class="text-end">${parseInt(con.timeEff).toLocaleString()}</td>
        <td>
            <span class="bi-window-plus text-primary" open-contract="${con.contractID}"></span>
        </td>
    </tr>`
  }).join('');
  const html =
    `<div class="col">
        <p>
            Blueprint Name: ${tableData.bpName} - ${tableData.bpID}
            <a class="btn btn-secondary btn-tiny" href="https://www.adam4eve.eu/contract_price.php?typeID=${tableData.bpID}" target="_blank">
                <span class="bi-currency-pound"></span>
            </a>
        </p>
        <p>Contracts - Total available: ${tableData.bpAvailability}</p>
        <table class="table table-sm">
            <thead>
                <tr>
                <th class="text-end">Price Per Run</th>
                <th class="text-end">Price</th>
                <th class="text-end">Quantity</th>
                <th class="text-end">Runs</th>
                <th class="text-end">Is BPC</th>
                <th class="text-end">Mat Eff</th>
                <th class="text-end">Time Eff</th>
                <th>Open</th>
                </tr>
            </thead>
            <tbody>
                ${conRows}
            </tbody>
        </table>
    </div>`;
  document.querySelector('.tab-contracts').innerHTML = html;
};
const displayTab = (tab) => {
  document.querySelectorAll('.tab').forEach(tabContent => {
    tabContent.style.display = tabContent.classList.contains(`tab-${tab}`) ? 'block' : 'none';
  });
  document.querySelectorAll('.nav-tabs .nav-link').forEach(navLink => {
    navLink.classList.contains(`nav-${tab}`) ? navLink.classList.add('active') : navLink.classList.remove('active');
  });
};
const bindNavClicks = () => {
  for (const navLink of [...document.querySelectorAll('.nav-tabs .nav-link')]) {
    navLink.addEventListener('click', (event) => {
      const tabName = [...event.target.classList].find(c => c !== 'nav-link' && c.startsWith('nav-')).replace('nav-', '');
      displayTab(tabName);
    });
  }
};
const bindOpenEVEWindow = () => {
  for (const windowLink of [...document.querySelectorAll('[open-contract]')]) {
    windowLink.addEventListener('click', (event) => {
      const windowID = event.target.getAttribute('open-contract');
      console.log('open-contract', windowID);
      openEVEContract(windowID);
    });
  }
  for (const windowLink of [...document.querySelectorAll('[open-market]')]) {
    windowLink.addEventListener('click', (event) => {
      const windowID = event.target.getAttribute('open-market');
      console.log('open-market', windowID);
      openEVEMarket(windowID);
    });
  }
  for (const windowLink of [...document.querySelectorAll('[open-information]')]) {
    windowLink.addEventListener('click', (event) => {
      const windowID = event.target.getAttribute('open-information');
      console.log('open-information', windowID);
      openEVEInformation(windowID);
    });
  }
};
const displayDataForBP = async (tableData) => {
  console.log('displayDataForBP', tableData);
  displayBPData(tableData);
  displayMaterialsData(tableData);
  displayCostsData();
  displayContractsData(tableData);
  //   displayTab('blueprint')
  bindOpenEVEWindow();
};

const Handsontable = window.Handsontable;

let types;
let typesMarketHistory;
let blueprints;
let tableDatas;
let systems;
let killItems;
let esiData;

const loadData = async () => {
  const typesRes = await window.fetch('/data/generated-types.json');
  types = await typesRes.json();
  const typesMarketHistoryRes = await window.fetch('/data/generated-types-market-history.json');
  typesMarketHistory = await typesMarketHistoryRes.json();
  const blueprintsRes = await window.fetch('/data/generated-blueprints.json');
  blueprints = await blueprintsRes.json();
  const blueprintsContractsRes = await window.fetch('/data/generated-blueprints-contracts.json');
  const blueprintContracts = await blueprintsContractsRes.json();
  for (const bpID of Object.keys(blueprintContracts)) {
    const bpC = blueprintContracts[bpID];
    const bp = blueprints[bpID];
    bp.blueprintContracts = bpC.contracts;
  }
  const systemsRes = await window.fetch('/data/generated-systems.json');
  systems = await systemsRes.json();
  const killItemsRes = await window.fetch('/data/generated-kill-items.json');
  killItems = await killItemsRes.json();
};
const formatDuration = (seconds) => {
  if (seconds === 0) return '0s'
  const units = [
    { label: 'd', seconds: 86400 },
    { label: 'h', seconds: 3600 },
    { label: 'm', seconds: 60 },
    { label: 's', seconds: 1 }
  ];
  return units
    .filter(unit => seconds >= unit.seconds)
    .map(unit => {
      const value = Math.floor(seconds / unit.seconds);
      seconds %= unit.seconds;
      return `${value}${unit.label}`
    })
    .join(' ')
};
const hasLearnedSkills = (requiredSkills) => {
  let skillsLearned = 0;
  let skillsNotLearned = 0;

  // console.log('requiredSkills', requiredSkills)

  for (const skillID in requiredSkills) {
    const requiredLevel = requiredSkills[skillID];
    // console.log('requiredSkills', requiredSkills, skillID, requiredLevel)
    if (esiData === undefined) {
      skillsNotLearned++;
      continue
    }
    const skill = esiData.skills.find(s => s.skill_id === parseInt(skillID));
    if (skill === undefined) {
      skillsNotLearned++;
      continue
    }
    if (skill.active_skill_level >= requiredLevel) {
      skillsLearned++;
    } else {
      skillsNotLearned++;
    }
  }
  // console.log('requiredSkills END', skillsLearned, skillsNotLearned)
  return {
    skillsLearned, skillsNotLearned
  }
};

const prepareData = async () => {
  tableDatas = [];
  const { systemIndexCost, facilityTax, sccSurchage } = getJobCostModifiers();
  const { brokersFee, salesTax } = getSaleCostModifiers();

  for (const bpID of Object.keys(blueprints)) {
    try {
      const bp = blueprints[bpID];
      const bpProductData = Object.values(bp.activities.manufacturing.products)[0];
      const productType = types[bpProductData.type_id];
      const marketHistory = typesMarketHistory[bpProductData.type_id];
      // console.log('productType', bp, bpProductData.type_id, productType)
      const bpMaterialsData = Object.values(bp.activities.manufacturing.materials);
      const productSellPrice = productType.sell.minval; // TODO - This is not necessarily correct, this is just the current cheapest sell order
      // const productSellPrice = productType.buy.maxval // TODO - This is not necessarily correct, this is just the current cheapest sell order
      const killItem = killItems[parseInt(bpProductData.type_id)];
      const tableData = {
        bpID: bp.blueprint_type_id,
        bpName: types[bp.blueprint_type_id].name.en,
        bpCostPerRun: bp.blueprintContracts.length > 0 ? bp.blueprintContracts[0].pricePerRun : 999999999999,
        bpAvailability: bp.blueprintContracts.map(con => con.quantity * con.runs).reduce((acc, tot) => acc + tot, 0),
        bp,
        killItem,
        killDiff2to7: (killItem.average2 - killItem.average7) / killItem.average2,
        killDiff2to30: (killItem.average2 - killItem.average30) / killItem.average2,
        killDiff7to90: (killItem.average7 - killItem.average90) / killItem.average7,
        killDiff7toYear: (killItem.average7 - killItem.averageYear) / killItem.average7,
        killAverageISK2: Math.round(killItem.average2 * productSellPrice),
        killAverageISK7: Math.round(killItem.average7 * productSellPrice),
        time: bp.activities.manufacturing.time,
        productID: bpProductData.type_id,
        productQuantity: bpProductData.quantity,
        productName: productType.name.en,
        productData: productType,
        groupName: productType.groupName,
        marketGroupName: productType.marketGroupName,
        metaGroupName: productType.metaGroupName,
        categoryName: productType.categoryName,
        productSellPrice,
        productSellPriceTotal: productSellPrice * bpProductData.quantity,
        productSellOrdersCount: productType.sell.numorders,
        productBuyOrdersCount: productType.buy.numorders,
        salesFees: parseInt(productSellPrice * bpProductData.quantity * brokersFee) + parseInt(productSellPrice * bpProductData.quantity * salesTax),
        materialsBuyPrice: 0,
        materialsSellPrice: 0,
        materials: bpMaterialsData,
        blueprintPricePerRun: bp.blueprintPricePerRun,
        eiv: 0,
        averagePrice: marketHistory.averagePrice,
        volume30Days: marketHistory.volume30Days,
        averageVolume: Math.round(marketHistory.averageVolume)
        // average_price: 0,
        // adjusted_price: 0
      };
      let matEff = 0;
      let timeEff = 0;
      if (bp.blueprintContracts.length > 0) {
        matEff = bp.blueprintContracts[0].matEff;
        timeEff = bp.blueprintContracts[0].timeEff;
      }
      // 4,530,921
      for (const material of bpMaterialsData) {
        const materialType = types[material.type_id];
        material.typeData = materialType;
        // material.eiv = materialType.eiv
        const quantity = getMaterialQuantity(material.quantity, matEff);
        // console.log(tableData.productName, '-', matEff, 'quantity', material.quantity, quantity)

        tableData.materialsBuyPrice += Math.ceil(materialType.buy.maxval * quantity);
        tableData.materialsSellPrice += Math.ceil(materialType.sell.minval * quantity);
        // tableData.eiv += ((materialType.eiv * material.quantity) / bpProductData.quantity)
        // tableData.average_price += ((materialType.average_price * material.quantity) / 1)
        tableData.eiv += (materialType.adjusted_price * material.quantity);
        if (tableData.productName === '\'Augmented\' Vespa') {
          console.log('materialType', materialType, materialType.type_id, materialType.name.en, materialType.sell.minval, materialType.buy.maxval, 'x', material.quantity, '=', parseInt(materialType.sell.minval * material.quantity), parseInt(materialType.buy.maxval * material.quantity));
        }
        if (materialType.adjusted_price === undefined) {
          console.log('MISSING adjusted_price', tableData.productName, '->', materialType.type_id, materialType.name.en, materialType);
        }
      }
      tableData.eiv = Math.round(tableData.eiv);

      tableData.jobCost = parseInt(tableData.eiv * systemIndexCost) + parseInt(tableData.eiv * facilityTax) + parseInt(tableData.eiv * sccSurchage);
      tableData.profitFromBuy =
        (tableData.productSellPrice * tableData.productQuantity) -
        tableData.bpCostPerRun -
        tableData.materialsBuyPrice -
        tableData.jobCost -
        tableData.salesFees;
      tableData.profitFromSell = (tableData.productSellPrice * tableData.productQuantity) - tableData.bpCostPerRun - tableData.materialsSellPrice - tableData.jobCost - tableData.salesFees;
      tableData.marginFromBuy = tableData.profitFromBuy / tableData.productSellPriceTotal;
      tableData.marginFromSell = tableData.profitFromSell / tableData.productSellPriceTotal;
      const sellCosts = (tableData.bpCostPerRun + tableData.materialsBuyPrice + tableData.jobCost + tableData.salesFees) * 0.8;
      tableData.totalCostsFromSell = tableData.bpCostPerRun + tableData.materialsSellPrice + tableData.jobCost + tableData.salesFees;
      tableData.mpp = Math.min(
        (((marketHistory.averagePrice * bpProductData.quantity) - sellCosts) * marketHistory.volume30Days),
        ((productSellPrice - sellCosts) * marketHistory.volume30Days)
      ) / 1000000000;
      tableData.profitPerHourFromBuy = parseInt(tableData.profitFromBuy / (tableData.time / 3600));
      tableData.profitPerHourFromSell = parseInt(tableData.profitFromSell / (tableData.time / 3600));
      tableData.sellerCompetition = productType.sell.volume / marketHistory.averageVolume;
      tableData.timeHuman = formatDuration(tableData.time);
      const { skillsLearned, skillsNotLearned } = hasLearnedSkills(bp.activities.manufacturing.required_skills);
      tableData.skillsLearned = skillsLearned;
      tableData.skillsNotLearned = skillsNotLearned;

      const maxUnitsProducedInADay = (86400 / tableData.time) * tableData.productQuantity;
      const saturation = maxUnitsProducedInADay / marketHistory.averageVolume;
      tableData.saturation = saturation;
      const debugProducts = ['Tetryon Exotic Plasma XL', 'Marshal', 'Tengu', '\'Augmented\' Vespa', 'Large Trimark Armor Pump I', 'Coupling Array'];
      if (debugProducts.includes(tableData.productName)) {
        console.log('tableData', tableData, bp, tableData.eiv, (tableData.eiv * systemIndexCost), (tableData.eiv * facilityTax), (tableData.eiv * sccSurchage), productType, marketHistory);
        console.log('sellerCompetition', productType.sell.volume, marketHistory.averageVolume, productType.sell.volume / marketHistory.averageVolume, marketHistory.averageVolume / productType.sell.volume);
        const worstSellPrice = Math.min(marketHistory.averagePrice, productSellPrice);
        const worstProfit = worstSellPrice - sellCosts;
        console.log('mpp', tableData.mpp, 'prices', marketHistory.averagePrice, productSellPrice, '->', worstSellPrice, 'volume', marketHistory.volume30Days, 'costs', sellCosts, 'profit', worstProfit, 'mpp', (worstProfit * marketHistory.volume30Days) / 1000000000);
        console.log('saturation', 'averageVolume', marketHistory.averageVolume, 'maxUnitsProducedInADay', maxUnitsProducedInADay, 'saturation', saturation);
      }
      tableDatas.push(tableData);
    } catch (error) {

    }
  }
};
const getSystemIDFromName = (name) => {
  return Object.keys(systems).find((key) => systems[key].solar_system_name === name)
};
const getJobCostModifiers = () => {
  const systemID = getSystemIDFromName('Kamokor'); // 3300000 - 890000
  // const systemID = getSystemIDFromName('Jita')
  const system = systems[systemID];
  console.log('systemCostIndex', system);
  // TODO - Implement dropdown etc
  const systemIndexCost = system.cost_indices.manufacturing;
  const facilityTax = 0.0025; // TODO - Get these properly
  const sccSurchage = 0.015; // TODO - Get these properly
  return { systemIndexCost, facilityTax, sccSurchage }
};

const createGrid = async () => {
  const container = document.querySelector('.data-table');
  const fields = [
    { data: 'productName', colName: 'Product Name' },
    { data: 'productID', colName: 'ID', type: 'numeric' },
    { data: 'groupName', colName: 'Group' },
    { data: 'categoryName', colName: 'Category' },
    { data: 'marketGroupName', colName: 'Market' },
    { data: 'metaGroupName', colName: 'Meta' },

    { data: 'profitFromBuy', colName: 'Profit Buy', type: 'numeric', numericFormat: { pattern: '0,0' }, colorScales: true, min: -50000000, max: 50000000 },
    { data: 'profitFromSell', colName: 'Profit Sell', type: 'numeric', numericFormat: { pattern: '0,0' }, colorScales: true, min: -50000000, max: 50000000 },
    { data: 'marginFromBuy', colName: 'Margin From Buy', type: 'numeric', numericFormat: { pattern: '0,0.00%' }, colorScales: true, min: -1, max: 1 },
    { data: 'marginFromSell', colName: 'Margin From Sell', type: 'numeric', numericFormat: { pattern: '0,0.00%' }, colorScales: true, min: -1, max: 1 },
    { data: 'profitPerHourFromBuy', colName: 'ISK/H Buy', type: 'numeric', numericFormat: { pattern: '0,0' }, colorScales: true, min: -50000000, max: 50000000 },
    { data: 'profitPerHourFromSell', colName: 'ISK/H Sell', type: 'numeric', numericFormat: { pattern: '0,0' }, colorScales: true, min: -50000000, max: 50000000 },

    { data: 'totalCostsFromSell', colName: 'Total Costs Sell', type: 'numeric', numericFormat: { pattern: '0,0' } },
    { data: 'productSellPrice', colName: 'Product Sell Price', type: 'numeric', numericFormat: { pattern: '0,0' } },
    { data: 'averageVolume', colName: 'Average Sales', type: 'numeric', numericFormat: { pattern: '0,0' }, colorScales: true, min: 0, max: 300 },
    { data: 'productSellOrdersCount', colName: 'Sell Orders', type: 'numeric' },
    { data: 'productBuyOrdersCount', colName: 'Buy Orders', type: 'numeric' },
    { data: 'sellerCompetition', colName: 'Seller Comp.', type: 'numeric', numericFormat: { pattern: '0,0.0' }, colorScales: true, min: 0, max: 15, colorInverse: true },
    { data: 'mpp', colName: 'MPP', type: 'numeric', numericFormat: { pattern: '0,0.0' }, colorScales: true, min: 0, max: 20 },
    { data: 'saturation', colName: 'Satur', type: 'numeric', numericFormat: { pattern: '0,0.0%' }, colorScales: true, min: 0, max: 1, colorInverse: true },

    { data: 'productQuantity', colName: 'Q' },

    { data: 'killDiff2to7', colName: 'K Trend 2-7', type: 'numeric', numericFormat: { pattern: '0,0.00%' } },
    { data: 'killDiff2to30', colName: 'K Trend 2-30', type: 'numeric', numericFormat: { pattern: '0,0.00%' } },
    { data: 'killDiff7to90', colName: 'K Trend 7-90', type: 'numeric', numericFormat: { pattern: '0,0.00%' } },
    { data: 'killDiff7toYear', colName: 'K Trend 7-Year', type: 'numeric', numericFormat: { pattern: '0,0.00%' } },

    { data: 'killAverageISK2', colName: 'K ISK 2', type: 'numeric', numericFormat: { pattern: '0,0' } },
    { data: 'killAverageISK7', colName: 'K ISK 7', type: 'numeric', numericFormat: { pattern: '0,0' } },

    { data: 'time', colName: 'Time' },
    { data: 'timeHuman', colName: 'Time Human' },
    { data: 'skillsLearned', colName: 'Skills Learned', type: 'numeric' },
    { data: 'skillsNotLearned', colName: 'Skills Not Learned', type: 'numeric', colorScales: true, min: 0, max: 1, colorInverse: true },

    { data: 'bpCostPerRun', colName: 'BP Cost', type: 'numeric', numericFormat: { pattern: '0,0' } },
    { data: 'bpAvailability', colName: 'BP Avail', type: 'numeric', numericFormat: { pattern: '0,0' } },
    { data: 'materialsBuyPrice', colName: 'Mats From Buy', type: 'numeric', numericFormat: { pattern: '0,0' } },
    { data: 'materialsSellPrice', colName: 'Mats From Sell', type: 'numeric', numericFormat: { pattern: '0,0' } },
    { data: 'jobCost', colName: 'Job Cost', type: 'numeric', numericFormat: { pattern: '0,0' } },
    { data: 'salesFees', colName: 'Sales Fees', type: 'numeric', numericFormat: { pattern: '0,0' } }
  ];
  function getMinMaxValues (objects, fields) {
    const result = {};
    fields.forEach((field) => {
      if (field.colorScales) {
        const key = field.data;
        const values = objects.map((obj) => obj[key]).filter((v) => !isNaN(v));
        console.log('getMinMaxValues', key, values);
        result[key] = {
          min: field.min === undefined ? Math.min(...values) : Math.max(Math.min(...values), field.min),
          max: field.max === undefined ? Math.max(...values) : Math.min(Math.max(...values), field.max)
        };
        if (field.colorInverse) result[key].colorInverse = field.colorInverse;
      }
    });
    return result
  }
  function calculateRGBA (min, max, actual, inverse) {
    let adjustedValue = actual + 0;
    if (adjustedValue > max) adjustedValue = max;
    if (adjustedValue < min) adjustedValue = min;
    const position = (adjustedValue - min) / (max - min);
    const r = Math.round(255 * (1 - position));
    const b = Math.round(255 * position);
    if (inverse) {
      return `rgba(${b},100,${r},0.8)`
    } else {
      return `rgba(${r},100,${b},0.8)`
    }
  }

  function negativeValueRenderer (instance, td, row, col, prop, value, cellProperties) {
    Handsontable.renderers.NumericRenderer.apply(this, arguments);
    // td.style.backgroundColor = `RGBA(${250 - parseInt(value) * 10}, 100,${parseInt(value) * 10}, 0.8)`
    td.style.color = '#eee';
    // td.innerHTML = `${td.innerHTML} &#8451; `
    const color = calculateRGBA(fieldsObj[prop].min, fieldsObj[prop].max, value, fieldsObj[prop].colorInverse);
    td.style.backgroundColor = color;
  }
  const getFieldIndex = (fieldName) => {
    return fields.findIndex(f => f.data === fieldName)
  };

  const fieldsObj = getMinMaxValues(tableDatas, fields);
  console.log('fieldsObj', fieldsObj);

  const hot = new Handsontable(container, {
    data: tableDatas,
    columns: fields, // .map(f => { return { data: f } }),
    colHeaders: fields.map(f => f.colName),
    rowHeaders: true,
    width: '100%',
    height: '100%',
    dropdownMenu: true,
    readOnly: true,
    licenseKey: 'non-commercial-and-evaluation',
    renderAllRows: false, // TODO
    columnSorting: true,
    filters: true,
    fixedColumnsLeft: 1,
    cells: function (row, col, prop) {
      const cellProperties = {};
      if (fieldsObj[prop] !== undefined) {
        cellProperties.renderer = negativeValueRenderer;
      }
      return cellProperties
    }
  });
  hot.getPlugin('columnSorting').sort({ column: getFieldIndex('profitPerHourFromSell'), sortOrder: 'desc' });
  const filters = hot.getPlugin('Filters');
  filters.addCondition(getFieldIndex('averageVolume'), 'gte', [10]);
  // filters.addCondition(getFieldIndex('skillsNotLearned'), 'eq', [0])
  // filters.addCondition(getFieldIndex('mpp'), 'gt', [1])
  // filters.addCondition(getFieldIndex('saturation'), 'lt', [0.5])
  filters.filter();

  hot.addHook('afterSelectionEnd', (row, prop, row2, prop2, selectionLayerLevel) => {
    if (row < 0 || prop < 0) return
    const productID = hot.getDataAtRow(row)[1];
    const tableData = tableDatas.find(d => d.productID === productID);
    console.log('afterSelectionEnd', row, prop, row2, prop2, selectionLayerLevel, productID, tableData);
    displayDataForBP(tableData);
  });

  document.querySelector('.clear-filters').addEventListener('click', () => {
    filters.clearConditions();
    filters.filter();
  });
  // console.log('table', table)
};

const isCheapestSignificantlyCheaper = (items, thresholdPercentage) => {
  if (items.length < 2) {
    // If there are fewer than 2 items, no comparison can be made
    return false
  }

  // Sort the items by price in ascending order
  const sortedItems = [...items].filter(b => b.isBPC === true).sort((a, b) => a.pricePerRun - b.pricePerRun);
  if (sortedItems.length < 2) {
    // If there are fewer than 2 items, no comparison can be made
    return false
  }
  // Get the price of the cheapest item
  const cheapestPrice = sortedItems[0].pricePerRun;

  // Get the price of the second cheapest item
  const secondCheapestPrice = sortedItems[1].pricePerRun;

  // Calculate the percentage difference
  const percentageDifference = ((secondCheapestPrice - cheapestPrice) / secondCheapestPrice) * 100;

  // Check if the cheapest item is significantly cheaper
  return percentageDifference >= thresholdPercentage
};

const identifyCheapContracts = async () => {
  for (const bpIDString in blueprints) {
    const bpID = parseInt(bpIDString);
    const bpName = types[bpID].name.en;
    const bpContracts = blueprints[bpID].blueprintContracts;
    const shouldBuy = isCheapestSignificantlyCheaper(bpContracts, 60);
    if (shouldBuy && bpContracts[0].pricePerRun > 1000000) {
      console.log('identifyCheapContracts', bpName, shouldBuy, bpContracts[0].pricePerRun, bpContracts[1].pricePerRun, bpContracts.sort((a, b) => a.pricePerRun - b.pricePerRun));
    }
  }
};
const init = async () => {
  console.log('init');
  const urlParams = new URLSearchParams(window.location.search);
  if (urlParams.has('code') && urlParams.has('state')) {
    triggerLoginReturnFlow();
  }
  // document.querySelector('.buttons').innerHTML = 'Actions - tbc'
  document.querySelector('.login').addEventListener('click', triggerLoginFlow);
  await loadData();
  esiData = await loadESIData();
  await prepareData();
  await createGrid();
  bindNavClicks();
  console.log('types', types);
  console.log('typesMarketHistory', typesMarketHistory);
  console.log('blueprints', blueprints);
  console.log('tableDatas', tableDatas);
  console.log('systems', systems);
  console.log('esiData', esiData);
  window.types = types;
  window.typesMarketHistory = typesMarketHistory;
  window.blueprints = blueprints;
  window.tableDatas = tableDatas;
  window.systems = systems;
  window.killItems = killItems;
  window.esiData = esiData;
  await identifyCheapContracts();
};

init();

/*
Hi, I hope you're well. I've got a question if that's ok.

I've got a tool that's starting to come together, but I'm just missing one thing to give me a little confidence, well, two things really. 1) A realistic selling price to base potential profit on and 2) a level of confidence of whether the item will sell.

1) Realistic selling price - I'm current calculating this from fuzzworks `current.sell.minval` (eg, cheapest current order). This is fine for a guess, but a lot of the time it's not realistic to sell at that price as there could be low sell trade volume, temporarily inflated prices (and therefore low trade volume) etc. So, thoughts? What do you do here? What do you generally advise?

2) Confidence of selling - Given the first ('realistic selling price'), I'm looking at last 7 day trade volumes, 30 day market volumes, buy/sell order ratio, market saturation (what % of the market could a single slot produce compared to what is traded in a single day), market competitivity ( ratio of sell orders relative to total volume traded). I'm finding a few positive results, but still not really cracking it here. Do you just have sell orders open for months / check and update them every day? Any pointers on this too would be good.

I will sell at a loss when it is in my interest, but I want to have a good idea of where my costs are compared to market.  I accumulate large quantities of inputs, in some cases months worth of trade activity as this allows me to normalize my costs during more volatile moments (generally also caused by me)

Are some of the material sell prices unreasonable or zero?!

Add type groups etc

Add skills requirement - Show learned skills vs unlearned

Fill orders from jita and perimeter only (if possible)

Some level of 'good or bad', ideally visualised with color

Market bars to display the last x something or other, bar chart etc

click blueprint costs to see blueprint costs
click materials cost to see material costs

update contract to also reflect plex costs as it seems the packrat has 500 plex + 20,000 ISK, but stays at PLEX in my figures

Ensure that the mat eff and time eff from the cheapest price per run blueprint are reflected in the mineral cost calculations
*/
